// function to print the stage name more clearly in the jenkins console output, can be called within each stage
def PrintStageName() {     TESTED-AND-WORKS
  echo "-----------------STAGE: ${env.STAGE_NAME}-----------------"
}

pipeline {

    //agent any
    //agent none           //if we want to specify different agents for different stages, we can set none here and then the agent under the stage

    agent {
        label 'linux-agents'
    }   

    // below needs to be configured first
    tools {
        maven 'jenkins-maven-3.8.6'
        jdk   'jenkins-jdk-11'
    }   

  triggers {  //before the stages, so no need to configure it seperately in diff section on jenkins gui
    pollSCM 'H/10 * * * *'
  }

    // Key value pairs which helps passing values to job during job runtime from outside of Jenkinsfile. Itâ€™s one way of externalizing configuration. These are GLOBAL USER DEFINED ENVIRONMENT variables.
    // We put it at the top before stages and these env variables will be available at any stage in pipeline. 
    /* Note - 2 other ways
       env variables can also be defined on the jenkins portal via Manage Jenkins > System Configuration > Configure System > Global Properties > Environment Variables
       Initialize Environment variables using sh scripts in Jenkinsfile
    */  
  environment {

    DOCKER_REGISTRY_URL = "https://registry.hub.docker.com"
    DOCKERHUB_USERNAME = "fedora800"
    DOCKERHUB_PASSWORD_TOKEN = "dckr_pat_bIVSJy3byydo43Wnzb6WxrV17Ag"
    DOCKER_IMAGE_TAG_1 = "${BUILD_NUMBER}"
    DOCKER_IMAGE_TAG_2 = "latest"

    GITHUB_REPO_URL = "https://github.com/fedora800/scratch_project.git"
    GITHUB_REPO_BRANCH = "main"
    GIT_HUB_CREDENTIALS = "j_github_credentials"

    APP_NAME = "basic-nginx-docker-app"


        SLACK_CHANNEL = "#deployment-notifications"
        SLACK_TEAM_DOMAIN = "MY-SLACK-TEAM"
        SLACK_TOKEN = credentials("slack_token")
        DEPLOY_URL = "https://deployment.example.com/"

        COMPOSE_FILE = "docker-compose.yml"
        REGISTRY_AUTH = credentials("docker-registry")
        STACK_PREFIX = "my-project-stack-name"
 
       USER_NAME = "joesmith"
       USER_ID = 115         // will be stored as a string value

       IS_BOOLEAN = false   // will be stored as a string value

       LS_OUTPUT = "${sh(script:'ls -lah', returnStdout: true).trim()}"

    }   

    // different types of parameters that can be set 
    // The parameters directive provides a way for Jenkins job to interact with Jenkins CI/CD users during the running of the build job.
    // we will see 'Build with Parameters' on the build after which it will PAUSE for us to INPUT values in the below prompts on the web page before we proceed.
    parameters {
        string(name: 'NAME', description: 'Please tell me your name?')
        text(name: 'DESC', description: 'Describe about the job details')
        booleanParam(name: 'SKIP_TEST', description: 'Want to skip running Test cases?')
        choice(name: 'BRANCH', choices: ['Master', 'Dev'], description: 'Choose branch')
        password(name: 'SONAR_SERVER_PWD', description: 'Enter SONAR password')
    }   

  stages {

        // stage-initialization
        stage('Initialization') { NOT-TESTED
            environment { 
                   JOB_TIME = sh (returnStdout: true, script: "date '+%F %T'").trim()
            }   
            steps {
                PrintStageName()
                sh 'echo $JOB_TIME'
            }   
        }   

      // will help us find all the env variables pre-defined for us to use in jenkinsfile
      stage('List All the Jenkins Environment Variables"){ NOT-TESTED
        steps {
          PrintStageName()
          sh "printenv | sort"
        }
      }

      // here i have done build_number and stage_name in 2 diff methods
      stage("Use and Print Some Env Variables"){ NOT-TESTED
        steps{
          echo "[1] - BUILD_NUMBER = ${env.BUILD_NUMBER} and the variable is called \${BUILD_NUMBER} or \${env.BUILD_NUMBER}"
          sh 'echo [2] - BUILD_NUMBER = $BUILD_NUMBER'

          echo "[1] - STAGE_NAME = ${env.STAGE_NAME}"
          sh 'echo [2] - STAGE_NAME = $STAGE_NAME'

          echo "Current user is ${env.USER_NAME}"
          echo "Current user id is ${env.USER_ID} type: ${env.USER_ID.class}"    // note that the values are all strings

        }
      }

    // stage set or use local environment variables in different sections
    stage("Set Env Variables for this Stage - 1") { NOT-TESTED
      environment {
        USER_PATH = "/home/joe"
      }
      steps {

        PrintStageName()
        script {
          env.FILENAME_1_SCR = "testfile-1.csv"
        }

        // IMP - this block will override all types of env variable, including GLOBAL
        withEnv(["FILENAME_2_WENV=here is some value"]) {
            echo "ANOTHER_ENV_VAR = ${env.ANOTHER_ENV_VAR}"
        }
        echo "GLOBAL ENV VARIABLE          - DEPLOY_URL = ${env.DEPLOY_URL}"
        echo "LOCAL ENV VARIABLE           - USER_PATH = ${env.USER_PATH}"
        echo "LOCAL ENV (SCRIPT) VARIABLE  - FILENAME_1_SCR = ${env.FILENAME_1_SCR}"
        echo "LOCAL ENV (WITHENV) VARIABLE - FILENAME_2_SCR = ${env.FILENAME_2_SCR}"
      }
    }


    stage("Clean Jenkins Workspace") { // TESTED-AND-WORKS
      steps {
        PrintStageName()
        script {
          cleanWs()
        }
      }
    }

        stage("Stage using Global Boolean Environment Variable") { NOT-TESTED
            steps {
                script {
                    if (env.IS_BOOLEAN) {
                        echo "You can see this message, because \"false\" String evaluates to Boolean.TRUE value"
                    }

                    // we need to call this method to use the boolean expression and value correctly
                    if (env.IS_BOOLEAN.toBoolean() == false) {
                        echo "You can see this message, because \"false\".toBoolean() returns Boolean.FALSE value"
                    }
                }
            }
        }

        // stage-print-params
        stage('Printing Parameters') { NOT-TESTED
            steps {
                echo "Hello ${params.NAME}"
                echo "Job Details: ${params.DESC}"
                echo "Skip Running Test case ?: ${params.SKIP_TEST}"
                echo "Branch Choice: ${params.BRANCH}"
                echo "SONAR Password: ${params.SONAR_SERVER_PWD}"
            }
        }


        stage('Print the output of ls command stored in Env Variable') { NOT-TESTED
            steps {
                echo "LS_OUTPUT = ${env.LS_OUTPUT}"
            }

        // stage-groovy-logic
        stage('Stage with Groovy code logic') { NOT-TESTED
            steps {
                script {
                    def name = "${params.NAME}"
                    def branch = "${params.BRANCH}"
                    if(branch == "Master") {
                        echo "hello $name, branch is $branch"
                    } else {
                        echo "hello $name, branch is (not master) $branch"
                    }
                }
            }
        }

    // stage-boolean-logic-expression
    stage("Stage with block to execute based on Boolean Condition on Env Variable") { NOT-TESTED
      when {
        expression {
          env.BUILD_SUCCESSFUL.toBoolean() = true
        }
      }
      steps {
        echo "Executing this block now that ${env.BUILD_SUCCESSFUL} is true ..."
      }
    }

        // stage-prepare
        stage("Prepare") { NOT-TESTED
            steps {
                bitbucketStatusNotify buildState: "INPROGRESS"
            }
        }


// --------------------------------------------------------------------------------
// GIT related stages -- (begin)

    stage('Pull Code from git PUBLIC repo')  { 		// TESTED-AND-WORKS
      steps {
        PrintStageName()
        script {
          try {
            // Pull code from a GitHub repository
            //git branch: 'main', url: 'https://github.com/fedora800/scratch_project.git'
            git branch: GITHUB_REPO_BRANCH, credentialsId: GIT_HUB_CREDENTIALS, url: GITHUB_REPO_URL
          }
          catch (err) {
            echo err
          }
        }
      }
    }


    stage('Pull Code from Private git repo -- method 2')  {		//TESTED-AND-WORKS
      steps {
        PrintStageName()
        git([url: GITHUB_REPO_URL, branch: GITHUB_REPO_BRANCH, credentialsId: GIT_HUB_CREDENTIALS])
     }
   }



    stage('Stage-Get-git-Repo -- using withCredentials function')  {		//TESTED-AND-WORKS
      steps {
        PrintStageName()
        withCredentials([gitUsernamePassword(credentialsId: 'j_github_credentials', gitToolName: 'git-tool')]) {
          sh "git fetch --all"
        }
      }
    }

// GIT related stages -- (end)
// --------------------------------------------------------------------------------


        // stage-git-repo-and-downloads
        stage('git repo connect and download files') {  NOT-TESTED
            //agent linux-agents   // if we want this specific stage to run on this labelled hosts
            steps {
                PrintStageName()
                script {
                         // Get some code from a GitHub repository
                         try{
                           // Get some code from a GitHub repository
                           #git 'https://github.com/LambdaTest/nightwatch-selenium-sample.git'
                           git url: 'https://github.com/naiveskill/devops.git', branch: 'main' 
                           //Download Tunnel Binary
                           sh "wget https://s3.amazonaws.com/lambda-tunnel/LT_Linux.zip"
                      
                           //Required if unzip is not installed
                           sh 'sudo apt-get install --no-act unzip'
                           sh 'unzip -o LT_Linux.zip'
                      
                         }
                         catch (err){
                           echo err
                         }
                }
             }
        }

        // stage-scm-checkout
        stage("SCM Checkout") { NOT-TESTED
        steps { echo "SCM Checkout"  }
        }

        // stage-build
        stage("Build and start test image") { NOT-TESTED
            steps {
                sh "docker-composer build"
                sh "docker-compose up -d"
            }
        }

        // stage-code-review
        stage("Code Review") { NOT-TESTED
        steps { echo "Code Review"  }
        }

        // stage-test
        /* can comprise of many different testing stages
           or even as many steps of a single test stage
        */
        stage("Unit Test") { NOT-TESTED
        steps { echo "Unit Test"  }
        }

        // stage-integration-test-1
        stage("Integration Test 1") { NOT-TESTED
        steps { echo "Integration Test 1"  }
        }

        // stage-smoke-test
        stage("Smoke Test") { NOT-TESTED
        steps { echo "Smoke Test"  }
        }

        // stage-end-to-end-test
        stage("End to End Test") { NOT-TESTED
        steps { echo "End to End Test"  }
        }

        // stage-metric-check
        stage("Metrics Check") { NOT-TESTED
        steps { echo "Metrics Check"  }
        }

        // stage-package
        stage("Package") { NOT-TESTED
        steps { echo "Package"  }
        }

        // stage-deploy
        stage("Deploy") { NOT-TESTED
        steps { echo "Deploy"  }
        }

        stage("Run tests") { NOT-TESTED
            steps {
                sh "docker-compose exec -T php-fpm composer --no-ansi --no-interaction tests-ci"
                sh "docker-compose exec -T php-fpm composer --no-ansi --no-interaction behat-ci"
            }

            post {
                always {
                    junit "build/junit/*.xml"
                    step([
                            $class              : "CloverPublisher",
                            cloverReportDir     : "build/coverage",
                            cloverReportFileName: "clover.xml"
                    ])
                }
            }
        }

        stage("Determine new version") { NOT-TESTED
            // Acts like if condition to decide whether to run the particular stage or not
            when {
                branch "master"
            }

            steps {
                script {
                    env.DEPLOY_VERSION = sh(returnStdout: true, script: "docker run --rm -v '${env.WORKSPACE}':/repo:ro softonic/ci-version:0.1.0 --compatible-with package.json").trim()
                    env.DEPLOY_MAJOR_VERSION = sh(returnStdout: true, script: "echo '${env.DEPLOY_VERSION}' | awk -F'[ .]' '{print \$1}'").trim()
                    env.DEPLOY_COMMIT_HASH = sh(returnStdout: true, script: "git rev-parse HEAD | cut -c1-7").trim()
                    env.DEPLOY_BUILD_DATE = sh(returnStdout: true, script: "date -u +'%Y-%m-%dT%H:%M:%SZ'").trim()

                    env.DEPLOY_STACK_NAME = "${env.STACK_PREFIX}-v${env.DEPLOY_MAJOR_VERSION}"
                    env.IS_NEW_VERSION = sh(returnStdout: true, script: "[ '${env.DEPLOY_VERSION}' ] && echo 'YES'").trim()
                }
            }
        }

        stage("Create new version") { NOT-TESTED
            when {
                branch "master"
                environment name: "IS_NEW_VERSION", value: "YES"
            }

            steps {
                script {
                    sshagent(['ci-ssh']) {
                        sh """
                            git config user.email "ci-user@email.com"
                            git config user.name "Jenkins"
                            git tag -a "v${env.DEPLOY_VERSION}" \
                                -m "Generated by: ${env.JENKINS_URL}" \
                                -m "Job: ${env.JOB_NAME}" \
                                -m "Build: ${env.BUILD_NUMBER}" \
                                -m "Env Branch: ${env.BRANCH_NAME}"
                            git push origin "v${env.DEPLOY_VERSION}"
                        """
                    }
                }

                sh "docker login -u=$REGISTRY_AUTH_USR -p=$REGISTRY_AUTH_PSW ${env.REGISTRY_ADDRESS}"
                sh "docker-compose -f ${env.COMPOSE_FILE} build"
                sh "docker-compose -f ${env.COMPOSE_FILE} push"
            }
        }


// --------------------------------------------------------------------------------
// DOCKER stages -- USING SHELL COMMANDS  (begin)

    stage("Build Docker Image - Using Shell commands") {                // TESTED-AND-WORKS
      steps {
        PrintStageName()
        script {
          sh "docker build --tag $DOCKERHUB_USERNAME/$APP_NAME:$DOCKER_IMAGE_TAG_1 --tag $DOCKERHUB_USERNAME/$APP_NAME:$DOCKER_IMAGE_TAG_2 ."
        }
      }
    }

    stage("Connect to Docker Registry and authenticate with credentials - Using Shell commands") {      // TESTED-AND-WORKS
      steps {
        PrintStageName()
        script {
          sh "hostnamectl"              // just run this shell command to show which jenkins agent/host this is being built on
          //sh "docker login -u ${env.dockerHubUser} -p ${env.dockerHubPassword}"
          //sh "sudo docker login -u ${env.DOCKERHUB_USERNAME} -p ${env.DOCKERHUB_PASSWORD_TOKEN}"
          // below is more secure practice
          //sh "echo $DOCKERHUB_PASSWORD_TOKEN | sudo docker login -u $DOCKERHUB_USERNAME --password-stdin"
          // throws below error -
//sudo: a terminal is required to read the password; either use the -S option to read from standard input or configure an askpass helper
//sudo: a password is required
          // but this is seen online - https://thetechdarts.com/deploy-to-dockerhub-using-jenkins-declarative-pipeline/ 
          // added jenkins userid to docker group and then did below, which worked
          sh "echo $DOCKERHUB_PASSWORD_TOKEN | docker login -u $DOCKERHUB_USERNAME --password-stdin"
        }
      }
    }


    stage("Push Docker Image - Using Shell commands") {         // TESTED-AND-WORKS
      steps {
        PrintStageName()
        script {
//        sh "docker push jsmith/spring-petclinic:latest" // example
          sh "docker push $DOCKERHUB_USERNAME/$APP_NAME:$DOCKER_IMAGE_TAG_1"
          sh "docker push $DOCKERHUB_USERNAME/$APP_NAME:$DOCKER_IMAGE_TAG_2"
        }
      }
    }

    stage("Logout from the Docker Registry - Using Shell commands") {           // TESTED-AND-WORKS
      steps {
        PrintStageName()
        script {
          sh "docker logout"
        }
      }
    }


    stage("Clean up local docker images - Using Shell commands") {              // TESTED-AND-WORKS
      steps {
        PrintStageName()
        script {
          sh "docker image rm $DOCKERHUB_USERNAME/$APP_NAME:$DOCKER_IMAGE_TAG_1"
          sh "docker image rm $DOCKERHUB_USERNAME/$APP_NAME:$DOCKER_IMAGE_TAG_2"
        }
      }
    }


// DOCKER stages -- USING SHELL COMMANDS  (end)
// --------------------------------------------------------------------------------


// --------------------------------------------------------------------------------
// DOCKER stages -- USING JENKINS FUNCTIONS  (begin)

//    stage("Connect to Docker Registry and authenticate with credentials - Using Jenkins function") {
//      steps {
//        PrintStageName()
//        script {
//          docker.withRegistry($DOCKER_REGISTRY_URL, 'docker-hub-credentials') {
//            // do what here ?
//          }
//        }
//      }
//    }


//    stage("Build Docker Image - Using Jenkins function -- found online 1") {
//      steps {
//        PrintStageName()
//        script {
//          docker.build("${DOCKER_HUB_USERNAME}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}")
//          eg. dockerImage = docker.build("monishavasu/my-react-app:latest")
//        }
//      }
//    }


//    stage("Build Docker Image - Using Jenkins function -- found online 2") {
//      steps {
//        PrintStageName()
//        script {
//          dockerImage = docker.build dregistry_and_repo + ":$BUILD_NUMBER"
//        }
//      }
//    }


//    stage("Push Docker Image - Using Jenkins function") {
//      steps {
//        PrintStageName()
//        script {
//          docker.withRegistry( '', $DOCKER_REGISTRY_CREDENTIALS ) {
//            dockerImage.push("$BUILD_NUMBER")
//            dockerImage.push('latest')
//            docker.push("${DOCKER_HUB_USERNAME}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}")     // another one

//          }
//        }
//      }
//    }

   stage("Push to Dockerhub") {      NOT-TESTED
     when { 
       equals 
          expected: "true", 
          actual: "${params.PushImage}" }
     steps {
       script {
         echo "Pushing the image to docker hub"
         def localImage = "${params.Image_Name}:${params.Image_Tag}"
      
         // pcheajra is my username in the DockerHub
         // You can use your username
         def repositoryName = "pchejara/${localImage}"
      
         // Create a tag that going to push into DockerHub
         sh "docker tag ${localImage} ${repositoryName} "
         docker.withRegistry("", "DockerHubCredentials") {
           def image = docker.image("${repositoryName}");
           image.push()
         }
       }
    }
  }
  post {
     always {
        script {
           echo "I am execute always"
        }
     }
     success {
        script {
           echo "I am execute on success"
        }
     }
     failure {
        script {
           echo "I am execute on failure"
        }
     }
  }

// DOCKER stages -- USING JENKINS FUNCTIONS  (end)
// --------------------------------------------------------------------------------

        // stage-docker-build
        stage('Build and Publish Docker Image') { NOT-TESTED
            when {
                branch 'master'  //only run these steps on the master branch
            }
            steps {
                /*
                 * Multiline strings can be used for larger scripts. It is also possible to put scripts in your shared library
                 * and load them with 'libaryResource'
                 */
                sh """
          docker build -t ${IMAGE} .
          docker tag ${IMAGE} ${IMAGE}:${VERSION}
          docker push ${IMAGE}:${VERSION}
        """
            }
            post {
                failure {
                    // notify users when this step fails
                    mail to: 'team@example.com',
                            subject: "Failed Pipeline: ${currentBuild.fullDisplayName}",
                            body: "Something is wrong with ${env.BUILD_URL}"
                }
            }
        }


        // stage-docker-hub
        stage("Push Newly Built Image to DockerHub") { NOT-TESTED

          steps {
             script {
               sh "sudo docker login -u ${DOCKERHUB_USERNAME} -p ${DOCKERHUB_CREDENTIALS}"
               sh "sudo docker push XXXX/YYYY"
             }
          }

        }

      stage("Build docker images") {		NOT-TESTED
         steps {
            script {
               echo "Bulding docker images"
               def buildArgs = """\
--build-arg HTTP_PROXY=${params.HTTP_PROXY} \
--build-arg HTTPS_PROXY=${params.HTTPS_PROXY} \
-f Dockerfile \
."""
                docker.build(
                   "${params.Image_Name}:${params.Image_Tag}",
                   buildArgs)
            }
         }
      }
   }

        // stage-prune-images
        stage("Prune Docker Images") { NOT-TESTED

          # this is not exactly prune, but just deleting the specific image 
          steps {
            script {
              sh "sudo docker image rm ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}"
              sh "sudo docker image rm ${DOCKER_IMAGE_NAME}:latest"
        }



        // stage-apply-docker-changes-to-kubernetes
        stage("Apply Docker Image changes into Kubernetes Deployment File") { NOT-TESTED

          steps {
            script {
              sh """
                 echo "--pre change--"; cat deployment.yml
                 sed -i 's/${APP_NAME}.*/${APP_NAME}:${DOCKER_IMAGE_TAG}/g' deployment.yml
                 echo "--post change--"; cat deployment.yml

                 sudo docker image rm ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}
                 sudo docker image rm ${DOCKER_IMAGE_NAME}:latest
              """
        }


        // stage-commit-kubernetes-changes
        stage("Push the Kubernetes Changes into git") { NOT-TESTED

          steps {
            script {
              sh """
                 git config --global user.name "fedora800"
                 git config --global user.email "fedora800@gmail.com"
                 git add deployment.yml
                 git commit -m "k8 deployment file updated - by jenkins - ${env.BUILD_NUMBER}"
              """
             withCredentials([gitUsernamePassword(credentialsId: 'jenkins-github-credentials-id', gitToolName: 'git-tool')]) {
               sh "git push https://github.com/fedora800/myproject1.git main"
             }
 
        }


        // stage-manual-approval
        stage("Manual Approval Before Deploying into Production") { NOT-TESTED
          steps {
            script {
              # gives approvers 10mins to approve, else abort this stage & pipeline
              timeout(10) {
                emailext body: "<br>Project: ${env.JOB_NAME} <br>Build Number: ${env.BUILD_NUMBER} <br>Build URL: ${env.BUILD_URL} <br> Please review & approve deployment via the Build URL link", recipientProviders: [[$class: 'DevelopersRecipientProvider'], [$class: 'RequesterRecipientProvider']], subject: 'Requesting Approval - ${env.BUILD_NUMBER} - ${env.BUILD_URL}'
                input {
                  message "Are you confirming to deploy change into Production ?"
                  ok "Deploy"
                }
              }
            }
          }

          post {
            always {
            }
          }
        }


        // stage-deploy-into-kubernetes
        stage("Deploy to Kubernetes Cluster") { NOT-TESTED
          sh "kubectl apply -f deployment.yml"
        }


        // stage-deploy-prod
        stage("Deploy to production") { NOT-TESTED
            agent { node { label "swarm-prod" } }

            when {
                branch "master"
                environment name: "IS_NEW_VERSION", value: "YES"
            }

            steps {
                sh "docker login -u=$REGISTRY_AUTH_USR -p=$REGISTRY_AUTH_PSW ${env.REGISTRY_ADDRESS}"
                sh "docker stack deploy ${env.DEPLOY_STACK_NAME} -c ${env.COMPOSE_FILE} --with-registry-auth"
            }

            post {
                success {
                    slackSend(
                            teamDomain: "${env.SLACK_TEAM_DOMAIN}",
                            token: "${env.SLACK_TOKEN}",
                            channel: "${env.SLACK_CHANNEL}",
                            color: "good",
                            message: "${env.STACK_PREFIX} production deploy: *${env.DEPLOY_VERSION}*. <${env.DEPLOY_URL}|Access service> - <${env.BUILD_URL}|Check build>"
                    )
                }

                failure {
                    slackSend(
                            teamDomain: "${env.SLACK_TEAM_DOMAIN}",
                            token: "${env.SLACK_TOKEN}",
                            channel: "${env.SLACK_CHANNEL}",
                            color: "danger",
                            message: "${env.STACK_PREFIX} production deploy failed: *${env.DEPLOY_VERSION}*. <${env.BUILD_URL}|Check build>"
                    )
                }
            }
        }

        // stage-verify-deployment
        stage("Verify App Deployment") { NOT-TESTED
          ## to do
        }


        // stage-monitor
        stage("Monitor") { NOT-TESTED
            steps { echo "Monitor"  }
        }

    } // end-stages

    // do below post all the stages
    post {
        always {
            sh "docker-compose down || true"
        }

        success {
            bitbucketStatusNotify buildState: "SUCCESSFUL"
        }

        failure {
          // notify users when the Pipeline fails
          mail to: 'team@example.com',
          subject: "Failed Pipeline: ${currentBuild.fullDisplayName}",
          body: "Something is wrong with ${env.BUILD_URL}"
    }
    }

}

