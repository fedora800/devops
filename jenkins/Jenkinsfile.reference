
/*
B00 -------------------- section : Environment Variables --------------------
C00 -------------------- section : Parameters --------------------
P00 -------------------- section : Beginning Stages --------------------
stage('P01 - Initialization - using 2 scripts/steps') { // TESTED-AND-WORKS
stage('P02 - List All the Jenkins Environment Variables') {  // NOT-TESTED
stage("P03 - Print Environment Variables - 2 different methods") { // TESTED-AND-WORKS
stage('P04 - Check Webhook Parameters') { // TESTED-AND-WORKS
stage('P05 - Print GitHub Webhook Headers on Generic Webhook Trigger') {  // TESTED-AND-WORKS
stage('P06 - Process Payload Received on the GitHub Webhook for the Generic Webhook Trigger') { //TESTED-AND-WORKS
D00 -------------------- section : Git Related --------------------
stage('D01 - Pull Code from git PUBLIC repo -- method 1 - using git branch')  { 		// TESTED-AND-WORKS
stage('D02 - Pull Code from Private git repo -- method 2 - using git() function')  {		//TESTED-AND-WORKS
stage('D03 - Checkout Code from git PRIVATE repo on github.com - using withCredentials usernamePassword')  { //TESTED-AND-WORKS
stage('D04 - Clone multiple git repos into seperate dirs and build them seperately') { //NOT-TESTED

E00 -------------------- section : Build Related --------------------
stage('E01 - Build using gradlew') { //NOT-TESTED
stage('E02 - Build Python Code - Frontend') { //NOT-TESTED
stage('E03 - Completely seperate Jenkinfile pipeline for Frontend') { // NOT-TESTED
stage('E04 - Completely seperate Jenkinfile pipeline for Backend') { // NOT-TESTED
stage('E05 - Call another Jenkins Build Pipeline/Job') {  //NOT-TESTED

F00 -------------------- section : Code Review Related --------------------

G00 -------------------- section : Testing Related --------------------
stage('G06 - Sonarqube Analysis') {  //NOT-TESTED


H00 -------------------- section : Metric Checks Related --------------------
I00 -------------------- section : Packaging Related --------------------

N00 -------------------- section : Approval Related --------------------
stage('N01 - Manual Approval Before Deploying into Production, Notification by Email') { // NOT-TESTED

J00 -------------------- section : Docker Related (Using Shell commands) --------------------
stage("J01 - Build Docker Image - Using Shell commands") {  // TESTED-AND-WORKS
stage("J02 - Connect to Docker Registry and authenticate with credentials - Using Shell commands") { // TESTED-AND-WORKS
stage("J03 - Push Docker Image - Using Shell commands") { // TESTED-AND-WORKS
stage("J04 - Logout from the Docker Registry - Using Shell commands") { // TESTED-AND-WORKS
stage("J05 - Clean up local docker images - Using Shell commands") { // TESTED-AND-WORKS
stage('J06 - Run Docker Container on Local Infrastructure configured in Jenkins') { //TESTED-AND-WORKS
stage('J07 - Remove old Docker images')  {    // CURRENTLY, its not printing FINAL REMOVE_LIST, though that variable is getting done properly in loop


K00 -------------------- section : Docker Related (Using Jenkins functions) --------------------

L00 -------------------- section : GitOps - Kubernetes Related --------------------
stage("L01 - Deploy to Kubernetes Cluster") { // NOT-TESTED
stage('L02 - CanaryDeploy') {   // NOT-TESTED
stage('L03 - Deploy To Production Kubernetes cluster') {  // NOT-TESTED
stage("L04 - Deploy to production") { // NOT-TESTED
stage("L05 - Trigger CD Pipeline") { // NOT-TESTED
stage("L06 - Verify App Deployment") {  // NOT-TESTED
stage("L07 - Monitor") {  // NOT-TESTED
stage('L08 - Deploy To Kubernetes using Jenkins Pipeline Plugin') { // NOT-TESTED
stage('L09 - Verify the Deployment using Jenkins Pipeline Plugin') { // NOT-TESTED
stage('L10 - Update K8S manifest & push to GitOps Repo') { // NOT-TESTED
stage('L11 - Update K8S manifest & push to GitOps Repo - Example 2') { // NOT-TESTED
stage('L12 - Clone GitOps Repo and push manifest file changes to this GitOps Repo') {  // TESTED-AND-WORKS
stage('L13 - Connect to Kubernetes cluster using config file credentials and lookup resources') { //TESTED-AND-WORKS
stage('L14 - Deploy to Kubernetes - Connect using config file credentials and APPLY manifest changes') {  //TESTED-AND-WORKS

M00 -------------------- section : Security Related --------------------
stage("M04 - Build Docker Image with version passed as argument- Using Shell commands") { //TESTED-AND-WORKS
stage('M05 - withCredentials - usernamePassword') { //NOT-TESTED
stage('M06 - withCredentials - usernameColonPassword') { //NOT-TESTED
stage('M07 - withCredentials - string (secret text)'') { //NOT-TESTED
stage('M08 - withCredentials - sshUserPrivateKey') { //NOT-TESTED
stage('M09 - withCredentials - dockerCert') { //NOT-TESTED
stage('M10 - withCredentials - list credentials ids') { //NOT-TESTED

// -------------------- Do Post for all stages --------------------

A00 -------------------- section : Functions --------------------
*/


// ----------------------------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------------------------


pipeline {

    //agent any
    //agent none           //if we want to specify different agents for different stages, we can set none here and then the agent under the stage

    agent {
        label 'linux-agents'
    }   

    // below needs to be configured first
    tools {
        maven 'jenkins-maven-3.8.6'
        jdk   'jenkins-jdk-11'
    }   

  //before the stages, so no need to configure it seperately in diff section on jenkins GUI and can be gitops'd here
  triggers {
    pollSCM 'H/10 * * * *'
    GenericTrigger(                               // i think this block is for the generic webhook trigger plugin
      genericVariables: [
        [key: 'ref', value: '$.ref'],
        [key: 'before', value: '$.before'],
        [key: 'after', value: '$.after'],
        [key: 'repo_url', value: '$.repository.url'],
      ],
      causeString: 'Triggered By Gitlab On $ref',
      token: 'gojenkinsdemorelease',
      tokenCredentialId: '',
      // filter the deletion of release branch
      regexpFilterText: '$after',
      regexpFilterExpression: '^(?!0000000000000000000000000000000000000000$).*$',
      printContributedVariables: true,
      printPostContent: true,
      silentResponse: false,
    )
  }

// B00 -------------------- section : Environment Variables --------------------

    // Key value pairs which helps passing values to job during job runtime from outside of Jenkinsfile. Itâ€™s one way of externalizing configuration. These are GLOBAL USER DEFINED ENVIRONMENT variables.
    // We put it at the top before stages and these env variables will be available at any stage in pipeline. 
    /* Note - 2 other ways
       env variables can also be defined on the jenkins portal via Manage Jenkins > System Configuration > Configure System > Global Properties > Environment Variables
       Initialize Environment variables using sh scripts in Jenkinsfile
       Must use Groovy string interpolation (${}) inside a double-quoted Groovy string (""").
       Groovy does not allow hyphens (-) in variable names or parameter names, as they are interpreted as a minus operator, so need to use _ in variables

    */  
  environment {

    // JOB_NAME  - this is the name of Jenkins pre-defined environment variable for this job/pipeline
    GIT_USER_NAME = "fedora800"

    APP_NAME = "basic-nginx-docker-app"   // should this also come in as some jenkins variable ? to analyze
    APP_VERSION_PREFIX = "1.0"            // currently hardcoding till i find solution to maybe get from build config or somewhere else
    APP_VERSION = "${APP_VERSION_PREFIX}.${env.BUILD_NUMBER}"      // Concatenate using Groovy string interpolation

    APP_GIT_REPO_NAME = "stocksanalyzer-system"
    APP_GIT_REPO_URL = "https://github.com/fedora800/stocksanalyzer-system.git"
    APP_GIT_REPO_BRANCH = "main"
    APP_GIT_CREDENTIALS_ID = "cred-github-fedora800-PAT"

    APP_GITOPS_REPO_NAME = "gitops-stocksanalyzer-system"
    APP_GITOPS_REPO_URL = 'https://github.com/fedora800/gitops-stocksanalyzer-system.git' // Replace with your actual GitOps repo URL
    APP_GITOPS_BRANCH = 'main' // Replace with the branch you want to update in the GitOps repo
    APP_GITOPS_CREDENTIALS_ID = "cred-github-fedora800-PAT"


    // String Interpolation in Groovy: To use environment variables or any dynamic content inside strings, Groovy requires the use of ${} for interpolation. This ensures that the content is evaluated properly.

    DOCKER_REGISTRY_URL = "https://registry.hub.docker.com"
    DOCKERHUB_CREDENTIALS = "j_dockerhub_credentials"
    DOCKERHUB_USERNAME = "fedora800"
    // DOCKERHUB_PASSWORD_TOKEN = "dckr_pat_bIVSJy3byydo43Wnzb6WxrV17Ag"     // to not use this unencrpyted, we might need to use jenkins functions to docker login instead of sh scripts
                                                                             // github push will also fail due to committing a password
    DOCKER_IMAGE_TAG_1 = "${env.APP_VERSION}"
    DOCKER_IMAGE_TAG_2 = "latest"

    K8S_NAMESPACE = 'default'
    K8S_DEPLOYMENT_FILE = 'kubernetes-manifests/frontend/dpl-frontend.yaml'
    K8S_SERVICES_FILE = 'kubernetes-manifests/frontend/svc-frontend.yaml'


    SLACK_CHANNEL = "#deployment-notifications"
    SLACK_TEAM_DOMAIN = "MY-SLACK-TEAM"
    SLACK_TOKEN = credentials("slack_token")
    DEPLOY_URL = "https://deployment.example.com/"
    // DOCKER_ID = credentials('J_DOCKER_ID')                 // where J_DOCKER_ID is defined as a credential of type secret text on jenkins gui
    // DOCKER_PASSWORD = credentials('J_DOCKER_PASSWORD')     // where J_DOCKER_PASSWORD is defined as a credential of type secret text on jenkins gui

    COMPOSE_FILE = "docker-compose.yml"
    REGISTRY_AUTH = credentials("docker-registry")
    //DOCKERHUB_CREDENTIALS= credentials('dockerhubcredentials')     

    STACK_PREFIX = "my-project-stack-name"

    USER_NAME = "joesmith"
    USER_ID = 115         // will be stored as a string value

    IS_BOOLEAN = false   // will be stored as a string value

    LS_OUTPUT = "${sh(script:'ls -lah', returnStdout: true).trim()}"

    SCANNER_HOME=tool 'sonar-scanner'
    AWS_ACCOUNT_ID = credentials('ACCOUNT_ID')
    AWS_ECR_REPO_NAME = credentials('ECR_REPO1')
    AWS_DEFAULT_REGION = 'us-east-1'
    REPOSITORY_URI = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/"


    }   


//-------------------- section : Parameters --------------------

    // different types of parameters that can be set 
    // The parameters directive provides a way for Jenkins job to interact with Jenkins CI/CD users during the running of the build job.
    // we will see 'Build with Parameters' on the Jenkins GUI page
    // i had to manually click to start the build after which it will PAUSE for us to INPUT values in the below prompts on the web page before we proceed.
    parameters {
      // below will show as a 1 line input box, if not put anything, it will take the defined default value
      string(name: 'GREETING', defaultValue: 'Hello', description: 'How should I greet the world?')
      // below will show as a 1 line input box, if not put anything, it will take as null
      string(name: 'NAME', description: 'Please tell me your name?')
      // below will show as large multiline input box, if not put anything, it will take as null
      text(name: 'DESC', description: 'Describe about the job details')
      // below will show a check box with the label and desc given, will take false if not checked
      booleanParam(name: 'SKIP_TEST', description: 'Want to skip running Test cases?')
      // below will show a dropdown box, will take the 1st choice by default if nothing selected
      choice(name: 'BRANCH', choices: ['Master', 'Dev'], description: 'Choose branch')
      // below will show a 1 line input box, will show as concealed and we can change it
      password(name: 'SONAR_SERVER_PWD', description: 'Enter SONAR password')
   
      // to suppress the below error
      // Sep 22 12:13:16 acg-control1 jenkins[448]: 2024-09-22 12:13:16.450+0000 [id=1183]#011WARNING#011hudson.model.ParametersAction#filter: Skipped parameter jenkins-generic-webhook-trigger-plugin_uuid as it is undefined on pipeline-stocksanalyzer-system (#236). Set -Dhudson.model.ParametersAction.keepUndefinedParameters=true to allow undefined parameters to be injected as environment variables or -Dhudson.model.ParametersAction.safeParameters=[comma-separated list] to whitelist specific parameter names, even though it represents a security breach or -Dhudson.model.ParametersAction.keepUndefinedParameters=false to no longer show this message.
      string(name: 'jenkins-generic-webhook-trigger-plugin_uuid', defaultValue: '', description: 'UUID from the Generic Webhook Trigger plugin')

    }   


  // $ grep -n "section|stage\(" Jenkinsfile.reference     # run this to get all the stages
  stages {

// P00 -------------------- section : Beginning Stages --------------------

      stage('P01 - Initialization - using 2 scripts/steps') { // TESTED-AND-WORKS
          steps {                                                               // NOTE - a stage block can contain ONLY ONE steps block
              script {                                                          // NOTE - steps can contains multiple script blocks, 
                                                                                //        each representing a group of related commands or scripts.
                                                                                // Each script block can contain one or more shell commands, making it possible to group related commands together. This helps keep related tasks organized while maintaining a single steps block.
                  PrintStageName()  // Print the name of the current stage
              }

              // Step 1: Get and print the Job Time
              script {
                  echo 'Step 1: env variable check'
                  def jobTime = sh(script: "date '+%F %T'", returnStdout: true).trim()
                  env.JOB_TIME = jobTime  // Store job time in the environment variable
                  echo "Job Time: ${env.JOB_TIME}"
              }

              // Step 2: Clean the Jenkins Workspace
              script {
                  echo 'Step 2: clean wkspace'
                  cleanWs()  // Clean the Jenkins workspace
                  echo "Workspace cleaned successfully."
              }
          }
      }



      // will help us find all the env variables pre-defined for us to use in jenkinsfile
      stage('P02 - List All the Jenkins Environment Variables') {  // NOT-TESTED
        steps {
          PrintStageName()
          sh "printenv | sort"
        }
      }

      // here i have printed env variables in 2 diff methods
      stage("P03 - Print Environment Variables - 2 different methods") { // TESTED-AND-WORKS
        steps{
          PrintStageName()
          // using environment variables populated by Jenkins
          echo "BUILD_NUMBER = ${env.BUILD_NUMBER}"
          echo "STAGE_NAME = ${env.STAGE_NAME}"
          echo "JOB_NAME=${env.JOB_NAME}"
          echo "NODE_NAME=${env.NODE_NAME}"
          echo "USER=${env.USER}"
          echo "WORKSPACE=${env.WORKSPACE}"
  
          // using environment variables but accesing via sh commands
          sh "BUILD_NUMBER=$BUILD_NUMBER"
          sh "JOB_NAME=$JOB_NAME"
  
          sh "printenv | sort"
          
          echo "NOTE: This will also include those passed from the GitHub webhook"    /* *** THIS DID NOT PRINT ANYTHING FROM THE WEBHOOK *** */
  
        }
      }


    // Sample output -> Received secret: Secret not provided
    stage('P04 - Check Webhook Parameters') { // TESTED-AND-WORKS
      steps {
        PrintStageName()
          script {
            echo "Received secret: ${params.cred_jenkins_token_for_github ?: 'Secret not provided'}"
          }
      }
    }


    stage('P05 - Print GitHub Webhook Headers on Generic Webhook Trigger') {  // TESTED-AND-WORKS
      steps {
        PrintStageName()
          script {
            // NOTE - each of these need to be individually set up on the Jenkins GUI under the "Header parameters" section
            // and the naming convention should be exactly like below example:
            // The "X-GitHub-Delivery" header should be set as Request Header = "x-github-delivery" and leave Value filter blank and here env.x_github_delivery.
            // these are a pain, capitals, hyphen and underscore variable names, so do exactly as done here and in GUI.

            def gitHubDelivery = env.x_github_delivery ?: 'Not available'
            def gitHubEvent = env.x_github_event ?: 'Not available'
            def githubHookId = env.x_github_hook_id ?: 'Not available'
            def gitHubInstallationTargetID = env.x_github_hook_installation_target_id ?: 'Not available'
            def gitHubInstallationTargetType = env.x_github_hook_installation_target_type ?: 'Not available'

            echo "X-GitHub-Delivery : ${gitHubDelivery}"
            echo "X-GitHub-Event : ${gitHubEvent}"
            echo "X-GitHub-Hook-ID : ${githubHookId}"
            echo "X-GitHub-Hook-Installation-Target-ID : ${gitHubInstallationTargetID}"
            echo "X-GitHub-Hook-Installation-Target-Type : ${gitHubInstallationTargetType}"

            //def headers = env.GENERIC_WEBHOOK_TRIGGER_HEADERS ?: 'No Headers Found'
            //echo "Webhook Headers: ${headers}"

            // env shows some interesting variables, need to check out later
            echo "-----------env print --- start ----"
            //sh 'env | sort'                           // too many rows, so for now just show top and bottom of it
            sh 'env > /tmp/env.txt'
            echo "shortened env list :"
            sh '(head -n 5; echo "..."; tail -n 5) < /tmp/env.txt'

            // NOTE: here i can see all the payload data nicely put into individual env variables with prefix of webhook_payload_
            // eg webhook_payload_ref=refs/heads/main
            //    webhook_payload_repository_git_url=git://github.com/fedora800/stocksanalyzer-system.git
            // and of course the whole json in webhook_payload which i am printing in the captureRawPayload_method_2 function
            echo "-----------env print --- end ----"
            // Store some values for use in the next section
            env.GITHUB_HOOK_TARGETID = gitHubInstallationTargetID

          }
      }
    }


    stage('P06 - Process Payload Received on the GitHub Webhook for the Generic Webhook Trigger') { //TESTED-AND-WORKS
            // NOTE - just the Payload, the HEADERS need to be processed differently
            steps {
                PrintStageName()
                script {
//def payload = env.GENERIC_WEBHOOK_TRIGGER_REQUEST_BODY ?: 'No Payload Found'
//echo "Webhook Payload: ${payload}"

                    try {
                        echo "-- Calling captureRawPayload_method_1()  --"
                        captureRawPayload_method_1()
                        echo "-- Calling captureRawPayload_method_2()  --"
                        // A variable called webhook_payload is configured on Jenkins under "Post content parameters"  with Expression = $ and JSONPATH option.
                        captureRawPayload_method_2()
                        echo "-- Calling extractWebhookInfo()  --"
                        extractWebhookInfo()
                        echo "-- Calling createBuildIdentifier()  --"
                        createBuildIdentifier()
                    } catch (Exception e) {
                        echo "Error processing webhook: ${e.message}"
                        currentBuild.result = 'FAILURE'
                    }
                }
            }
    }




    // stage set or use local environment variables in different sections
    stage("Set Env Variables for this Stage - 1") { NOT-TESTED
      environment {
        USER_PATH = "/home/joe"
      }
      steps {

        PrintStageName()
        script {
          env.FILENAME_1_SCR = "testfile-1.csv"
        }

        // IMP - this block will override all types of env variable, including GLOBAL
        withEnv(["FILENAME_2_WENV=here is some value"]) {
            echo "ANOTHER_ENV_VAR = ${env.ANOTHER_ENV_VAR}"
        }
        echo "GLOBAL ENV VARIABLE          - DEPLOY_URL = ${env.DEPLOY_URL}"
        echo "LOCAL ENV VARIABLE           - USER_PATH = ${env.USER_PATH}"
        echo "LOCAL ENV (SCRIPT) VARIABLE  - FILENAME_1_SCR = ${env.FILENAME_1_SCR}"
        echo "LOCAL ENV (WITHENV) VARIABLE - FILENAME_2_SCR = ${env.FILENAME_2_SCR}"
      }
    }


        stage("Stage using Global Boolean Environment Variable") { NOT-TESTED
            steps {
                script {
                    if (env.IS_BOOLEAN) {
                        echo "You can see this message, because \"false\" String evaluates to Boolean.TRUE value"
                    }

                    // we need to call this method to use the boolean expression and value correctly
                    if (env.IS_BOOLEAN.toBoolean() == false) {
                        echo "You can see this message, because \"false\".toBoolean() returns Boolean.FALSE value"
                    }
                }
            }
        }

        // stage-print-params
        stage('Printing Parameters') { NOT-TESTED
            steps {
                echo "Greeting : ${params.GREETING} World!"
                echo "Hi ${params.NAME}"
                echo "Job Details: ${params.DESC}"
                echo "Skip Running Test case ?: ${params.SKIP_TEST}"
                echo "Branch Choice: ${params.BRANCH}"
                echo "SONAR Password: ${params.SONAR_SERVER_PWD}"
            }
        }


        stage('Print the output of ls command stored in Env Variable') { NOT-TESTED
            steps {
                echo "LS_OUTPUT = ${env.LS_OUTPUT}"
            }

        // stage-groovy-logic
        stage('Stage with Groovy code logic') { NOT-TESTED
            steps {
                script {
                    def name = "${params.NAME}"
                    def branch = "${params.BRANCH}"
                    if(branch == "Master") {
                        echo "hello $name, branch is $branch"
                    } else {
                        echo "hello $name, branch is (not master) $branch"
                    }
                }
            }
        }

    // stage-boolean-logic-expression
    stage("Stage with block to execute based on Boolean Condition on Env Variable") { NOT-TESTED
      when {
        expression {
          env.BUILD_SUCCESSFUL.toBoolean() = true
        }
      }
      steps {
        echo "Executing this block now that ${env.BUILD_SUCCESSFUL} is true ..."
      }
    }

        // stage-prepare
        stage("Prepare") { NOT-TESTED
            steps {
                bitbucketStatusNotify buildState: "INPROGRESS"
            }
        }


// D00 -------------------- section : Git Related --------------------

    stage('D01 - Pull Code from git PUBLIC repo -- method 1 - using git branch')  { 		// TESTED-AND-WORKS
      steps {
        PrintStageName()
        script {
          try {
            echo "Cloning repository ${APP_GIT_REPO_URL} from branch ${APP_GIT_REPO__BRANCH}"
            // Pull code from a GitHub repository
            //git branch: 'main', url: 'https://github.com/fedora800/scratch_project.git'
            git branch: APP_GIT_REPO_BRANCH, credentialsId: APP_GIT_CREDENTIALS_ID, url: APP_GIT_REPO_URL
          }
          catch (err) {
            echo err
          }
        }
      }
    }


    stage('D02 - Pull Code from Private git repo -- method 2 - using git() function')  {		//TESTED-AND-WORKS
      steps {
        PrintStageName()
        echo "Cloning repository ${APP_GIT_REPO_URL} from branch ${APP_GIT_REPO__BRANCH}"
        git([url: APP_GIT_REPO_URL, branch: APP_GIT_REPO_BRANCH, credentialsId: APP_GIT_CREDENTIALS_ID])
      }
    }

    stage('D03 - Checkout Code from git PRIVATE repo on github.com - using withCredentials usernamePassword')  { //TESTED-AND-WORKS
      steps {
        PrintStageName()
        script {
          try {

            // Use Jenkins credentials to access the repository
            withCredentials([usernamePassword(credentialsId: env.APP_GIT_CREDENTIALS_ID, passwordVariable: 'VAR_PAT', usernameVariable: 'VAR_USER')]) {
              echo "Cloning repository ${APP_GIT_REPO_URL} from branch ${APP_GIT_REPO__BRANCH}"
              //below is not going to work as this variable is the complete URL itself, so will need to change the variable if we want to use it
              //git branch: env.APP_GIT_REPO_BRANCH, url: "https://${VAR_USER}:${VAR_PAT}@${env.APP_GIT_REPO_URL}"
              //git branch: env.APP_GIT_REPO_BRANCH, url: "https://${VAR_USER}:${VAR_PAT}@github.com/fedora800/stocksanalyzer-system.git"
              git( branch: 'main', credentialsId: "cred-github-fedora800-PAT", url: "https://${VAR_USER}:${VAR_PAT}@github.com/fedora800/stocksanalyzer-system.git")

            }
          }  catch (Exception e) {
            echo "An error occurred: ${e.message}"
            // Fail the stage and stop the pipeline
            error("Stopping pipeline due to error in this stage.")
          }
        }
      }
    }

    
    stage('D04 - Clone multiple git repos into seperate dirs and build them seperately') { //NOT-TESTED
        steps {
            script {
                // Clone Repo 1
                dir('repo1') {
                    git url: 'https://github.com/yourorg/repo1.git', branch: 'main', credentialsId: 'cred-id-repo1'
                }

                // Clone Repo 2
                dir('repo2') {
                    git url: 'https://github.com/yourorg/repo2.git', branch: 'main', credentialsId: 'cred-id-repo2'
                }

                // Build Repo 1
                dir('repo1') {
                    echo 'Building Repo 1...'
                    // Add your build commands here for repo1
                    sh 'make build-repo1'  // Example build command
                }

                // Build Repo 2
                dir('repo2') {
                    echo 'Building Repo 2...'
                    // Add your build commands here for repo2
                    sh 'make build-repo2'  // Example build command
                }
            }
        }
    }



//    this is not required as we have defined a Declarative checkout by enabling Poll-SCM build trigger and configuring the Pipeline script from SCM on Jenkins GUI
//    stage('Stage-Get-git-Repo -- using withCredentials function')  {		//TESTED-AND-WORKS
//      steps {
//        PrintStageName()
//        withCredentials([gitUsernamePassword(credentialsId: 'j_APP_GIT_CREDENTIALS_ID', gitToolName: 'git-tool')]) {
//          sh "git fetch --all"
//        }
//      }
//    }



        // stage-git-repo-and-downloads
        stage('git repo connect and download files') {  NOT-TESTED
            //agent linux-agents   // if we want this specific stage to run on this labelled hosts
            steps {
                PrintStageName()
                script {
                         // Get some code from a GitHub repository
                         try{
                           // Get some code from a GitHub repository
                           #git 'https://github.com/LambdaTest/nightwatch-selenium-sample.git'
                           git url: 'https://github.com/naiveskill/devops.git', branch: 'main' 
                           //Download Tunnel Binary
                           sh "wget https://s3.amazonaws.com/lambda-tunnel/LT_Linux.zip"
                      
                           //Required if unzip is not installed
                           sh 'sudo apt-get install --no-act unzip'
                           sh 'unzip -o LT_Linux.zip'
                      
                         }
                         catch (err){
                           echo err
                         }
                }
             }
        }

        // stage-scm-checkout
        stage("SCM Checkout") { NOT-TESTED
        steps { echo "SCM Checkout"  }
        }

        // stage-build
        stage("Build and start test image") { NOT-TESTED
            steps {
                sh "docker-composer build"
                sh "docker-compose up -d"
            }
        }


// E00 -------------------- section : Build Related --------------------

        // stage-build-gradle
        stage('E01 - Build using gradlew') { // NOT-TESTED
          steps {
            echo 'Running build automation'
            sh './gradlew build --no-daemon'
            archiveArtifacts artifacts: 'dist/trainSchedule.zip'
          }
        }

      stage('E02 - Build Python Code - Frontend') { // NOT-TESTED
        steps {
          PrintStageName()
          sh '''
          cd src/frontend
          pip install -r requirements.txt
          '''
        }
      }

    stage('E03 - Completely seperate Jenkinfile pipeline for Frontend') { // NOT-TESTED
    // https://github.com/LondheShubham153/TWSThreeTierAppChallenge/blob/main/Jenkins-Pipeline-Code/Jenkinsfile-Frontend
    }

    stage('E04 - Completely seperate Jenkinfile pipeline for Backend') { // NOT-TESTED
    // https://github.com/LondheShubham153/TWSThreeTierAppChallenge/blob/main/Jenkins-Pipeline-Code/Jenkinsfile-Backend
    }

    stage('E05 - Call another Jenkins Build Pipeline/Job') {  //NOT-TESTED
      steps {
        PrintStageName()
          echo "Firing/Triggering jobs pipeline-stocksanalyzer-system-backend ..."
          build job: 'pipeline-stocksanalyzer-system-backend', parameters: [string(name: 'DOCKERTAG', value: env.BUILD_NUMBER)]
      }
    }


  stage("E06 - Build Docker Image with version passed as argument- Using Shell commands") {  // TESTED-AND-WORKS
    steps {
      PrintStageName()
      script {
//            sh echo -e "e[33m THIS IS NOT WORKING, SKIPPING FOR NOW ....e[0m"
        sh """
           sudo docker build -f src/frontend/Dockerfile  --build-arg APP_VERSION=${env.APP_VERSION} \
           --tag ${env.DOCKERHUB_USERNAME}/${env.APP_NAME}:${DOCKER_IMAGE_TAG_1} --tag ${DOCKERHUB_USERNAME}/${env.APP_NAME}:${DOCKER_IMAGE_TAG_2} src/frontend
        """
      }
    }
  }




// -------------------- section : Code Review Related --------------------
        // stage-code-review
        stage("Code Review") { NOT-TESTED
        steps { echo "Code Review"  }
        }

// G00 -------------------- section : Testing Related --------------------

        // stage-test
        /* can comprise of many different testing stages
           or even as many steps of a single test stage
        */
        stage("Unit Test") { NOT-TESTED
        steps { echo "Unit Test"  }
        }

        // stage-integration-test-1
        stage("Integration Test 1") { NOT-TESTED
        steps { echo "Integration Test 1"  }
        }

        // stage-smoke-test
        stage("Smoke Test") { NOT-TESTED
        steps { echo "Smoke Test"  }
        }

        // stage-end-to-end-test
        stage("End to End Test") { NOT-TESTED
        steps { echo "End to End Test"  }
        }

        stage("Run tests") { NOT-TESTED
            steps {
                sh "docker-compose exec -T php-fpm composer --no-ansi --no-interaction tests-ci"
                sh "docker-compose exec -T php-fpm composer --no-ansi --no-interaction behat-ci"
            }

            post {
                always {
                    junit "build/junit/*.xml"
                    step([
                            $class              : "CloverPublisher",
                            cloverReportDir     : "build/coverage",
                            cloverReportFileName: "clover.xml"
                    ])
                }
            }
        }


    stage('G06 - Sonarqube Analysis') {  // NOT-TESTED
      steps {
        dir('Application-Code/frontend') {
          withSonarQubeEnv('sonar-server') {
            sh ''' $SCANNER_HOME/bin/sonar-scanner \
              -Dsonar.projectName=three-tier-frontend \
              -Dsonar.projectKey=three-tier-frontend '''
          }
        }
      }
    }

    stage('G07 - SonarQube Analsyis') { // NOT-TESTED
      steps {
        withSonarQubeEnv('sonar') {
          sh ''' $SCANNER_HOME/bin/sonar-scanner -Dsonar.projectName=BoardGame -Dsonar.projectKey=BoardGame \
            -Dsonar.java.binaries=. '''
        }
      }
    }


        stage('Quality Gate/Check') {
            steps {
                script {
                  waitForQualityGate abortPipeline: false, credentialsId: 'sonar-token' 
                }
            }
        }



// -------------------- section : Metric Checks Related --------------------
        // stage-metric-check
        stage("Metrics Check") { NOT-TESTED
        steps { echo "Metrics Check"  }
        }

// -------------------- section : Packaging Related --------------------
        // stage-package
        stage("Package") { NOT-TESTED
        steps { echo "Package"  }
        }

        // stage-deploy
        stage("Deploy") { NOT-TESTED
        steps { echo "Deploy"  }
        }


        stage("Determine new version") { NOT-TESTED
            // Acts like if condition to decide whether to run the particular stage or not
            when {
                branch "master"
            }

            steps {
                script {
                    env.DEPLOY_VERSION = sh(returnStdout: true, script: "docker run --rm -v '${env.WORKSPACE}':/repo:ro softonic/ci-version:0.1.0 --compatible-with package.json").trim()
                    env.DEPLOY_MAJOR_VERSION = sh(returnStdout: true, script: "echo '${env.DEPLOY_VERSION}' | awk -F'[ .]' '{print \$1}'").trim()
                    env.DEPLOY_COMMIT_HASH = sh(returnStdout: true, script: "git rev-parse HEAD | cut -c1-7").trim()
                    env.DEPLOY_BUILD_DATE = sh(returnStdout: true, script: "date -u +'%Y-%m-%dT%H:%M:%SZ'").trim()

                    env.DEPLOY_STACK_NAME = "${env.STACK_PREFIX}-v${env.DEPLOY_MAJOR_VERSION}"
                    env.IS_NEW_VERSION = sh(returnStdout: true, script: "[ '${env.DEPLOY_VERSION}' ] && echo 'YES'").trim()
                }
            }
        }

        stage("Create new version") { NOT-TESTED
            when {
                branch "master"
                environment name: "IS_NEW_VERSION", value: "YES"
            }

            steps {
                script {
                    sshagent(['ci-ssh']) {
                        sh """
                            git config user.email "ci-user@email.com"
                            git config user.name "Jenkins"
                            git tag -a "v${env.DEPLOY_VERSION}" \
                                -m "Generated by: ${env.JENKINS_URL}" \
                                -m "Job: ${env.JOB_NAME}" \
                                -m "Build: ${env.BUILD_NUMBER}" \
                                -m "Env Branch: ${env.BRANCH_NAME}"
                            git push origin "v${env.DEPLOY_VERSION}"
                        """
                    }
                }

                sh "docker login -u=$REGISTRY_AUTH_USR -p=$REGISTRY_AUTH_PSW ${env.REGISTRY_ADDRESS}"
                sh "docker-compose -f ${env.COMPOSE_FILE} build"
                sh "docker-compose -f ${env.COMPOSE_FILE} push"
            }
        }

        
        stage('Build') {
            steps {
               sh "mvn package"
            }
        }
        
        stage('Publish To Nexus') {
            steps {
               withMaven(globalMavenSettingsConfig: 'global-settings', jdk: 'jdk17', maven: 'maven3', mavenSettingsConfig: '', traceability: true) {
                    sh "mvn deploy"
                }
            }
        }

		stage('OWASP Dependency Check') {
            steps {
               dependencyCheck additionalArguments: ' --scan ./ ', odcInstallation: 'DC'
                    dependencyCheckPublisher pattern: '**/dependency-check-report.xml'
            }
        }

// J00 -------------------- section : Docker Related (Using Shell commands) --------------------

    stage("J01 - Build Docker Image - Using Shell commands") {  // TESTED-AND-WORKS
      steps {
        PrintStageName()
        script {
          sh "docker build --tag $DOCKERHUB_USERNAME/$APP_NAME:$DOCKER_IMAGE_TAG_1 --tag $DOCKERHUB_USERNAME/$APP_NAME:$DOCKER_IMAGE_TAG_2 ."
        }
      }
    }

    stage("J02 - Connect to Docker Registry and authenticate with credentials - Using Shell commands") { // TESTED-AND-WORKS
      steps {
        PrintStageName()
        script {
          sh "hostnamectl"              // just run this shell command to show which jenkins agent/host this is being built on
          //sh "docker login -u ${env.dockerHubUser} -p ${env.dockerHubPassword}"
          //sh "sudo docker login -u ${env.DOCKERHUB_USERNAME} -p ${env.DOCKERHUB_PASSWORD_TOKEN}"
          // below is more secure practice
          //sh "echo $DOCKERHUB_PASSWORD_TOKEN | sudo docker login -u $DOCKERHUB_USERNAME --password-stdin"
          // throws below error -
//sudo: a terminal is required to read the password; either use the -S option to read from standard input or configure an askpass helper
//sudo: a password is required
          // but this is seen online - https://thetechdarts.com/deploy-to-dockerhub-using-jenkins-declarative-pipeline/ 
          // added jenkins userid to docker group and then did below, which worked
          sh "echo $DOCKERHUB_PASSWORD_TOKEN | docker login -u $DOCKERHUB_USERNAME --password-stdin"
        }
      }
    }


    stage("J03 - Push Docker Image - Using Shell commands") { // TESTED-AND-WORKS
      steps {
        PrintStageName()
        script {
//        sh "docker push jsmith/spring-petclinic:latest" // example
          sh "docker push $DOCKERHUB_USERNAME/$APP_NAME:$DOCKER_IMAGE_TAG_1"
          sh "docker push $DOCKERHUB_USERNAME/$APP_NAME:$DOCKER_IMAGE_TAG_2"
        }
      }
    }

    stage("J04 - Logout from the Docker Registry - Using Shell commands") { // TESTED-AND-WORKS
      steps {
        PrintStageName()
        script {
          sh "docker logout"
        }
      }
    }


    stage("J05 - Clean up local docker images - Using Shell commands") { // TESTED-AND-WORKS
      steps {
        PrintStageName()
        script {
          sh "docker image rm $DOCKERHUB_USERNAME/$APP_NAME:$DOCKER_IMAGE_TAG_1"
          sh "docker image rm $DOCKERHUB_USERNAME/$APP_NAME:$DOCKER_IMAGE_TAG_2"
        }
      }
    }

    // Need to document and print which server Jenkins will run this on
    stage('J06 - Run Docker Container on Local Infrastructure configured in Jenkins') { //TESTED-AND-WORKS
            steps {
                script {
                    PrintStageName()
                    try {
                        // Stop and remove any existing container with the same name
                        sh """
                            if [ \$(sudo docker container ls -a -f name=${env.APP_NAME} -q) ]; then
                                sudo docker stop ${env.APP_NAME}
                                sudo docker rm -f ${env.APP_NAME}
                            fi
                        """

                        // Run the Docker container
                        sh """
                           sudo docker run -d --name ${env.APP_NAME} \
                           --publish ${DOCKER_PUBLISHED_PORT}:${DOCKER_CONTAINER_PORT} ${DOCKERHUB_USERNAME}/${APP_NAME}:${DOCKER_IMAGE_TAG_2} \
                           ${env.APP_NAME}
                        """
                        // sudo docker run -d --name stocksanalyzer-frontend-app --publish 80:8501 fedora800/stocksanalyzer-frontend-app:latest stocksanalyzer-frontend-    app
                    } catch (Exception e) {
                        echo "Failed to run Docker container: ${e}"
                        currentBuild.result = 'FAILURE'
                    }
                }
            }
    }

    stage('J07 - Remove old Docker images')  {    // CURRENTLY, its not printing FINAL REMOVE_LIST, though that variable is getting done properly in loop
      steps {
        // Clean up temporary files, containers, etc.
        echo 'Cleaning up...'

        script {
          PrintStageName()  
  
          // This will remove all dangling images (images with no tags)
          sh "sudo docker image prune -f"
  
          // Remove specific images older than a specified number of days
          sh '''
            DAYS_OLD=30

            # Get current date in seconds since epoch
            current_date=$(date +%F)

            REMOVE_LIST=""
            # Convert current date to epoch time format
            current_date_epoch=$(date -d "$current_date" +%s)
            # List images and filter based on creation date
            sudo docker images --format "{{.ID}} {{.Repository}} {{.Tag}} {{.CreatedAt}}" | while read -r id repo tag created_at; do
                # Extract date part from created_at and remove timezone info
                formatted_date=$(echo "$created_at" | awk '{print $1}')
                # Convert creation date to epoch time format
                created_date_epoch=$(date -d "$formatted_date" +%s 2>/dev/null)

                if [ -z "$created_date_epoch" ]; then
                    echo "Date parsing failed for image $repo:$tag"
                    continue
                fi

                # Calculate age in days
                age_days=$(( (current_date_epoch - created_date_epoch) / 86400 ))

                if [ "$age_days" -ge "$DAYS_OLD" ]; then
                  echo "$id - $repo:$tag is $age_days days old and will be deleted"
                  echo "REMOVE_LIST DEBUG1 ====${REMOVE_LIST}==="
                  REMOVE_LIST="${REMOVE_LIST} $id"
                  echo "REMOVE_LIST DEBUG2 ====${REMOVE_LIST}==="
                fi
            done
            echo "Deleting old Docker images..."
            echo "REMOVE_LIST ----------------FINAL------------ ====${REMOVE_LIST}==="
            sudo docker image rm -f $REMOVE_LIST
          '''
        }
      } //steps
    }

    stage("ECR Image Pushing") {
      steps {
        script {
          sh 'aws ecr get-login-password --region ${AWS_DEFAULT_REGION} | docker login --username AWS --password-stdin ${REPOSITORY_URI}'
            sh 'docker tag ${AWS_ECR_REPO_NAME} ${REPOSITORY_URI}${AWS_ECR_REPO_NAME}:${BUILD_NUMBER}'
            sh 'docker push ${REPOSITORY_URI}${AWS_ECR_REPO_NAME}:${BUILD_NUMBER}'
        }
      }
    }



  stage('Docker Login using Jenkins Credentials ID') {
      steps {
        PrintStageName()
        script {
          // Fetch the username and password token from credentials id and assign values to local variables
          withCredentials([usernamePassword(credentialsId: 'cred_dockerhub', usernameVariable: 'DOCKER_USERNAME', passwordVariable: 'DOCKER_TOKEN')]) {
            // Securely perform Docker login using local environment variables
            // triple single (''') quotes for sh step to ensure that multi-line commands and variable expansions are handled properly by the shell.
            sh '''
            echo "$DOCKER_TOKEN" | sudo docker login -u "$DOCKER_USERNAME" --password-stdin
            '''
          }
        }
        script {
          sh '''
          echo "Builds that are available to push for this app:"
          sudo docker image ls | egrep "REPO|${APP_NAME}"
          '''
        }
      }
  }



  stage("Push Docker Image - Using Shell commands") {
    steps {
      PrintStageName()
      script {
        sh "sudo docker push ${DOCKERHUB_USERNAME}/${APP_NAME}:${DOCKER_IMAGE_TAG_1}"
        sh "sudo docker push ${DOCKERHUB_USERNAME}/${APP_NAME}:${DOCKER_IMAGE_TAG_2}"
      }
    }
  }




// -------------------- section : Docker Related (Using Jenkins functions) --------------------


    stage("Connect to Docker Registry and authenticate with credentials - Using Jenkins function") {           // TESTED-AND-WORKS
      steps {
        PrintStageName()
          script {
            // needs Docker Pipeline plugin
            // Connect to Docker Registry
            //docker.withRegistry($DOCKER_REGISTRY_URL, $DOCKERHUB_CREDENTIALS) {
            docker.withRegistry('https://registry.hub.docker.com', 'j_dockerhub_credentials') {
            // Build the image locally
            def myDockerImage1 = docker.build("${DOCKERHUB_USERNAME}/${APP_NAME}:${DOCKER_IMAGE_TAG_1}")
            def myDockerImage2 = docker.build("${DOCKERHUB_USERNAME}/${APP_NAME}:${DOCKER_IMAGE_TAG_2}")
  //          eg. dockerImage = docker.build("monishavasu/my-react-app:latest")
            /* Push the container to the Docker Registry */
            myDockerImage1.push()
            myDockerImage2.push()
          }
        }
      }
    }

   stage("Push to Dockerhub") {      NOT-TESTED
     when { 
       equals 
          expected: "true", 
          actual: "${params.PushImage}" }
     steps {
       script {
         echo "Pushing the image to docker hub"
         def localImage = "${params.Image_Name}:${params.Image_Tag}"
      
         // pcheajra is my username in the DockerHub
         // You can use your username
         def repositoryName = "pchejara/${localImage}"
      
         // Create a tag that going to push into DockerHub
         sh "docker tag ${localImage} ${repositoryName} "
         docker.withRegistry("", "DockerHubCredentials") {
           def image = docker.image("${repositoryName}");
           image.push()
         }
       }
    }
  }
  post {
     always {
        script {
           echo "I am execute always"
        }
     }
     success {
        script {
           echo "I am execute on success"
        }
     }
     failure {
        script {
           echo "I am execute on failure"
        }
     }
  }




// M00 -------------------- section : Security Related --------------------

    // stage-trivy-artifact-scan
    stage("M01 - Scan the Docker Image with Trivy using static analysis for vulneribilities") { // NOT-TESTED
      steps {
        sh "trivy image --format table -o trivy-image-report.html adijaiswal/boardshack:latest "
      }
    }


    stage('M02 - File System Scan') { //NOT-TESTED
        steps {
            sh "trivy fs --format table -o trivy-fs-report.html ."
        }
    }


        // stage-docker-build
        stage('Build and Publish Docker Image') { NOT-TESTED
            when {
                branch 'master'  //only run these steps on the master branch
            }
            steps {
                /*
                 * Multiline strings can be used for larger scripts. It is also possible to put scripts in your shared library
                 * and load them with 'libaryResource'
                 */
                sh """
                  docker build -t ${IMAGE} .
                  docker tag ${IMAGE} ${IMAGE}:${VERSION}
                  docker push ${IMAGE}:${VERSION}
                """

            }
            post {
                failure {
                    // notify users when this step fails
                    mail to: 'team@example.com',
                            subject: "Failed Pipeline: ${currentBuild.fullDisplayName}",
                            body: "Something is wrong with ${env.BUILD_URL}"
                }
            }
        }



    // https://www.codurance.com/publications/2019/05/30/accessing-and-dumping-jenkins-credentials
    stage('M05 - withCredentials - usernamePassword') { //NOT-TESTED
      steps {
        script {
          withCredentials([
            usernamePassword(credentialsId: 'gitlab',
              usernameVariable: 'username',
              passwordVariable: 'password')
          ]) {
            print 'username=' + username + 'password=' + password

            print 'username.collect { it }=' + username.collect { it }
            print 'password.collect { it }=' + password.collect { it }
          }
        }
      }
    }

    stage('M06 - withCredentials - usernameColonPassword') { //NOT-TESTED
      steps {
        script {
          withCredentials([
            usernameColonPassword(
              credentialsId: 'gitlab',
              variable: 'userpass')
          ]) {
            print 'userpass=' + userpass
            print 'userpass.collect { it }=' + userpass.collect { it }
          }
        }
      }
    }

    stage('M07 - withCredentials - string (secret text)'') { //NOT-TESTED
      steps {
        script {
          withCredentials([
            string(
              credentialsId: 'joke-of-the-day',
              variable: 'joke')
          ]) {
            print 'joke=' + joke
            print 'joke.collect { it }=' + joke.collect { it }
          }
        }
      }
    }

    stage('M08 - withCredentials - sshUserPrivateKey') { //NOT-TESTED
      steps {
        script {
          withCredentials([
            sshUserPrivateKey(
              credentialsId: 'production-bastion',
              keyFileVariable: 'keyFile',
              passphraseVariable: 'passphrase',
              usernameVariable: 'username')
          ]) {
            print 'keyFile=' + keyFile
            print 'passphrase=' + passphrase
            print 'username=' + username
            print 'keyFile.collect { it }=' + keyFile.collect { it }
            print 'passphrase.collect { it }=' + passphrase.collect { it }
            print 'username.collect { it }=' + username.collect { it }
            print 'keyFileContent=' + readFile(keyFile)
          }
        }
      }
    }

    stage('M09 - withCredentials - dockerCert') { //NOT-TESTED
      steps {
        script {
          withCredentials([
            dockerCert(
              credentialsId: 'production-docker-ee-certificate',
              variable: 'DOCKER_CERT_PATH')
          ]) {
            print 'DOCKER_CERT_PATH=' + DOCKER_CERT_PATH
            print 'DOCKER_CERT_PATH.collect { it }=' + DOCKER_CERT_PATH.collect { it }
            print 'DOCKER_CERT_PATH/ca.pem=' + readFile("$DOCKER_CERT_PATH/ca.pem")
            print 'DOCKER_CERT_PATH/cert.pem=' + readFile("$DOCKER_CERT_PATH/cert.pem")
            print 'DOCKER_CERT_PATH/key.pem=' + readFile("$DOCKER_CERT_PATH/key.pem")
          }
        }
      }
    }

    stage('M10 - withCredentials - list credentials ids') { //NOT-TESTED
      steps {
        script {
          sh 'cat $JENKINS_HOME/credentials.xml | grep "<id>"'
        }
      }
    }

//--------------------------------------------------------------------------------

        // stage-docker-hub
        stage("Push Newly Built Image to DockerHub") { NOT-TESTED

          steps {
             script {
               sh "sudo docker login -u ${DOCKERHUB_USERNAME} -p ${DOCKERHUB_CREDENTIALS}"
               sh "sudo docker push XXXX/YYYY"
             }
          }

        }

      stage("Build docker images") {		NOT-TESTED
         steps {
            script {
               echo "Bulding docker images"
               def buildArgs = """\
--build-arg HTTP_PROXY=${params.HTTP_PROXY} \
--build-arg HTTPS_PROXY=${params.HTTPS_PROXY} \
-f Dockerfile \
."""
                docker.build(
                   "${params.Image_Name}:${params.Image_Tag}",
                   buildArgs)
            }
         }
      }
   }

        // stage-prune-images
        stage("Prune Docker Images") { NOT-TESTED

          # this is not exactly prune, but just deleting the specific image 
          steps {
            script {
              sh "sudo docker image rm ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}"
              sh "sudo docker image rm ${DOCKER_IMAGE_NAME}:latest"
        }



        // stage-apply-docker-changes-to-kubernetes
        stage("Apply Docker Image changes into Kubernetes Deployment File") { NOT-TESTED

          steps {
            script {
              sh """
                 echo "--pre change--"; cat deployment.yml
                 sed -i 's/${APP_NAME}.*/${APP_NAME}:${DOCKER_IMAGE_TAG}/g' deployment.yml
                 echo "--post change--"; cat deployment.yml

                 sudo docker image rm ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}
                 sudo docker image rm ${DOCKER_IMAGE_NAME}:latest
              """
        }


        // stage-commit-kubernetes-changes
        stage("Push the Kubernetes Changes into git") { NOT-TESTED

          steps {
            script {
              sh """
                 git config --global user.name "fedora800"
                 git config --global user.email "fedora800@gmail.com"
                 git add deployment.yml
                 git commit -m "k8 deployment file updated - by jenkins - ${env.BUILD_NUMBER}"
              """
             withCredentials([gitUsernamePassword(credentialsId: 'jenkins-github-credentials-id', gitToolName: 'git-tool')]) {
               sh "git push https://github.com/fedora800/myproject1.git main"
             }
 
        }

        // stage-push-to-gitops-git-repo-manifest-file      
        stage("Push the changed deployment file to Git") {
            steps {
                sh """
                    git config --global user.name "dmancloud"
                    git config --global user.email "dinesh@dman.cloud"
                    git add deployment.yaml
                    git commit -m "Updated Deployment Manifest"
                """
                withCredentials([gitUsernamePassword(credentialsId: 'github', gitToolName: 'Default')]) {
                    sh "git push https://github.com/dmancloud/gitops-complete-prodcution-e2e-pipeline main"
                }
            }
        }

    // stage-input-basic-manual-approval
    /*
       On GUI, will wait for this stage, when clicked it will show my msg "Are you confirming to deploy change into Production ?" with button options of "Yes" and "Abort"
       if clicked on "Yes" --->
[Pipeline] stage
[Pipeline] { (Manual Approval Before Deploying into Production) (hide)
[Pipeline] input
Are you confirming to deploy change into Production ?
Yes or Abort
Approved by Admin User
[Pipeline] echo
-----------------Manual Approval Before Deploying into Production-----------------
[Pipeline] echo
User has confirmed production deployment ...
[Pipeline] echo
Now deploying to PROD ...
Post stage
[Pipeline] echo
--in post always--
[Pipeline] }
[Pipeline] // stage
[Pipeline] }
[Pipeline] // withEnv
[Pipeline] }
[Pipeline] // withEnv
[Pipeline] }
[Pipeline] // node
[Pipeline] End of Pipeline
       On clicking abort, job status will change to Aborted and console output ---->
Rejected by Admin User
org.jenkinsci.plugins.workflow.actions.ErrorAction$ErrorId: 4c852ee0-24fb-4c9a-986a-d680f42acf41
Finished: ABORTED
    */
    stage("Manual Approval Before Deploying into Production") { // TESTED-AND-WORKS
      input {
        message "Are you confirming to deploy change into Production ?"
        ok "Yes"
        //submitter: list of users or groups who are allowed to submit this input, default is any user.
        //submitter "ssbostan,admin,admins,managers"
        //submitterParameter: if this option is used, can be used to set submitter username in the environment variables.
        //submitterParameter "SUBMITTER_USERNAME"
      }
      steps {
        PrintStageName()
        echo "User has confirmed production deployment ..."
        echo "Now deploying to PROD ..."
      }
      post {
        always {
          echo "--in post always--"
        }
      }
    }

    // stage-input-param-get-choice
    stage("Manual Choice of values using parameters") {       // TESTED-AND-WORKS
      steps {
        PrintStageName()
        script {
          env.MY_CHOICE_ENV = input message: 'User input required',
            parameters: [choice(name: 'Whats your choice ? ', choices: 'no\nyes', description: 'Choose "yes" if you want to deploy this build')]
        }
      }
    }


    // if we had chosen "yes", it will print "You had selected (yes) - yes ..."
    // if we had chosen "no", it will completely skip this stage due to the when conditional
    stage('Inform about the choice Variable') {            // TESTED-AND-WORKS
      when {
        environment name: 'MY_CHOICE_ENV', value: 'yes'
      }
      steps {
        PrintStageName()
        echo "You had selected (yes) - ${env.MY_CHOICE_ENV} ..."
      }
    }


    // stage-input-request-username-password
    stage ("Request UserName and Password") {    // TESTED-AND-WORKS
      steps {
        PrintStageName()
        script {
          env.USERNAME = input message: 'Please enter the username',
            parameters: [string(defaultValue: '', description: 'Username for the app', name: 'Username')]
          env.PASSWORD = input message: 'Please enter the password',
            parameters: [password(defaultValue: '', description: 'Passwd for the app', name: 'Password')]
        }
        echo "Username: ${env.USERNAME}"
        echo "Password: ${env.PASSWORD}"
      }
    }

    // stage-input-multiple-parameters
    // the stage will wait with a popup showing "Select options: The paused input step uses advanced input options. <href Please redirect to approve >
    // where once clicked on the above href, it will take us to a page which will ask us to put all the inputs
    // the echo will give -> Env: [Options:Foo, textInput:data-textInput-box, submitterBy:admin, Check1:false, credentialsParam:, inputText:data-inputText-row-box, PasswordField:None, textField:data-textField-box]
    stage("Take in as Input Multiple Parameters") {   //TESTED-AND-WORKS
      steps {
        timeout(time: 2, unit: 'HOURS') { //SECONDS | MINUTES | HOURS | DAYS
          script {
            def userInput =
                  input( id: 'input'
                    , message: 'Select options :'
      //            , submitter: 'asanchez' // only this user can submit the form, comment to skip
                    , submitterParameter: 'submitterBy' // return the name of the user submitter
                    , parameters: [
                       //Params
                       booleanParam(name: 'Check1', defaultValue: false)
                       , [$class: 'TextParameterDefinition', defaultValue: 'Dummy Text', description: 'A simple text param', name: 'textInput']
                       , text(defaultValue: 'LOREM', description: '', name: 'textField')
                       , string(defaultValue: 'dummy text', description: '', name: 'inputText', trim: false)
                       , credentials(credentialType: 'com.cloudbees.plugins.credentials.impl.UsernamePasswordCredentialsImpl', defaultValue: '', description: '', name: 'credentialsParam', required: true)
                     , choice(choices: ['Foo', 'Bar', 'Sed'], description: '', name: 'Options')
                     , password(defaultValue: 'None', description: '', name: 'PasswordField')
                       ])

                   echo("Env: " + userInput)

          }
        }
      }
    }

      // multiple services, each with it's own stage
      stage('adservice') {
            steps {
                script{
                    withDockerRegistry(credentialsId: 'docker-cred', toolName: 'docker') {
                          dir('/var/lib/jenkins/workspace/10-Tier/src/adservice/') {
                                 sh "docker build -t adijaiswal/adservice:latest ."
                                 sh "docker push adijaiswal/adservice:latest"
								 sh " docker rmi adijaiswal/adservice:latest"
                        }
                    }
                }
            }
        }
		
		stage('cartservice') {
            steps {
                script{
                    withDockerRegistry(credentialsId: 'docker-cred', toolName: 'docker') {
                          dir('/var/lib/jenkins/workspace/10-Tier/src/cartservice/src/') {
                                 sh "docker build -t adijaiswal/cartservice:latest ."
                                 sh "docker push adijaiswal/cartservice:latest"
								 sh " docker rmi adijaiswal/cartservice:latest"
                        }
                    }
                }
            }
        }
		
		stage('checkoutservice') {
            steps {
                script{
                    withDockerRegistry(credentialsId: 'docker-cred', toolName: 'docker') {
                          dir('/var/lib/jenkins/workspace/10-Tier/src/checkoutservice/') {
                                 sh "docker build -t adijaiswal/checkoutservice:latest ."
                                 sh "docker push adijaiswal/checkoutservice:latest"
								 sh " docker rmi adijaiswal/checkoutservice:latest"
                        }
                    }
                }
            }
        }



// N00 -------------------- section : Approval Related --------------------
        stage('N01 - Manual Approval Before Deploying into Production, Notification by Email') { // NOT-TESTED
          steps {
            script {
              # gives approvers 10mins to approve, else abort this stage & pipeline
              timeout(10) {
                emailext body: "<br>Project: ${env.JOB_NAME} <br>Build Number: ${env.BUILD_NUMBER} <br>Build URL: ${env.BUILD_URL} <br> Please review & approve deployment via the Build URL link", recipientProviders: [[$class: 'DevelopersRecipientProvider'], [$class: 'RequesterRecipientProvider']], subject: 'Requesting Approval - ${env.BUILD_NUMBER} - ${env.BUILD_URL}'
                input {
                  message "Are you confirming to deploy change into Production ?"
                  ok "Deploy"
                }
              }
            }
          }

          post {
            always {
            }
          }
        }


        // stage-update-manifest-files-into-a-seperate-gitops-repo
        stage("Change the Kubernetes Manifest files and git push them into the seperate GitOps repo") { NOT-TESTED
        // ArgoCD will be monitoring this gitops repo and will apply this updated deployment.yml to kubernetes cluster automatically
           script {
             catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
               withCredentials([usernamePassword(credentialsId: 'github', passwordVariable: 'GIT_PASSWORD', usernameVariable: 'GIT_USERNAME')]) {
                 //def encodedPassword = URLEncoder.encode("$GIT_PASSWORD",'UTF-8')
                 sh "git config user.email raj@cloudwithraj.com"
                 sh "git config user.name RajSaha"
                 //sh "git switch master"
                 sh "cat deployment.yaml"
                 sh "sed -i 's+raj80dockerid/test.*+raj80dockerid/test:${DOCKERTAG}+g' deployment.yaml"
                 sh "cat deployment.yaml"
                 sh "git add ."
                 sh "git commit -m 'Done by Jenkins Job changemanifest: ${env.BUILD_NUMBER}'"
                 sh "git push https://${GIT_USERNAME}:${GIT_PASSWORD}@github.com/${GIT_USERNAME}/kubernetesmanifest.git HEAD:main"
               }
             }
           }
        }

        stage("Deploy To Tomcat"){
          steps{
            sh "cp  /var/lib/jenkins/workspace/CI-CD/target/petclinic.war /opt/apache-tomcat-9.0.65/webapps/ "
          }
        }

// L00 -------------------- section : GitOps - Kubernetes Related --------------------

        stage('L01 - Deploy to Kubernetes Cluster') { // NOT-TESTED
          // just deployment and services here for now
          // in reality, there will be many other kubernetes resources to be deployed
          sh "kubectl apply -f deployment.yml"
          sh "kubectl apply -f service.yml"
          sh "kubectl get deployments"
          sh "kubectl get services"
        }

        // stage-canary-deploy
        stage('L02 - CanaryDeploy') {   // NOT-TESTED
          when {
            branch 'master'
          }
          environment {
            CANARY_REPLICAS = 1
          }
          steps {
            kubernetesDeploy(
              kubeconfigId: 'kubeconfig',
              configs: 'train-schedule-kube-canary.yml',
              enableConfigSubstitution: true
            )
          }
        }
      
        //stage-deploy-to-prod-kubernetes-cluster
        stage('L03 - Deploy To Production Kubernetes cluster') {  // NOT-TESTED
            when {
                branch 'master'
            }
            environment {
                CANARY_REPLICAS = 0
            }
            steps {
                input 'Deploy to Production?'
                milestone(1)
                kubernetesDeploy(
                    kubeconfigId: 'kubeconfig',
                    configs: 'train-schedule-kube-canary.yml',
                    enableConfigSubstitution: true
                )
                kubernetesDeploy(
                    kubeconfigId: 'kubeconfig',
                    configs: 'train-schedule-kube.yml',
                    enableConfigSubstitution: true
                )
            }
        }

        // stage-deploy-prod
        stage('L04 - Deploy to production') { // NOT-TESTED
            agent { node { label "swarm-prod" } }

            when {
                branch "master"
                environment name: "IS_NEW_VERSION", value: "YES"
            }

            steps {
                sh "docker login -u=$REGISTRY_AUTH_USR -p=$REGISTRY_AUTH_PSW ${env.REGISTRY_ADDRESS}"
                sh "docker stack deploy ${env.DEPLOY_STACK_NAME} -c ${env.COMPOSE_FILE} --with-registry-auth"
            }

            post {
                success {
                    slackSend(
                            teamDomain: "${env.SLACK_TEAM_DOMAIN}",
                            token: "${env.SLACK_TOKEN}",
                            channel: "${env.SLACK_CHANNEL}",
                            color: "good",
                            message: "${env.STACK_PREFIX} production deploy: *${env.DEPLOY_VERSION}*. <${env.DEPLOY_URL}|Access service> - <${env.BUILD_URL}|Check build>"
                    )
                }

                failure {
                    slackSend(
                            teamDomain: "${env.SLACK_TEAM_DOMAIN}",
                            token: "${env.SLACK_TOKEN}",
                            channel: "${env.SLACK_CHANNEL}",
                            color: "danger",
                            message: "${env.STACK_PREFIX} production deploy failed: *${env.DEPLOY_VERSION}*. <${env.BUILD_URL}|Check build>"
                    )
                }
            }
        }


        stage('L05 - Trigger CD Pipeline') { // NOT-TESTED
            steps {
                script {
                    sh "curl -v -k --user admin:${JENKINS_API_TOKEN} -X POST -H 'cache-control: no-cache' -H 'content-type: application/x-www-form-urlencoded' --data 'IMAGE_TAG=${IMAGE_TAG}' 'https://jenkins.dev.dman.cloud/job/gitops-complete-pipeline/buildWithParameters?token=gitops-token'"
                }
            }

        }


        // stage-verify-deployment
        stage('L06 - Verify App Deployment') {  // NOT-TESTED
          ## to do
        }


        // stage-monitor
        stage('L07 - Monitor') {  // NOT-TESTED
            steps { echo "Monitor"  }
        }

        stage('L08 - Deploy To Kubernetes using Jenkins Pipeline Plugin') { // NOT-TESTED
            steps {
               withKubeConfig(caCertificate: '', clusterName: 'kubernetes', contextName: '', credentialsId: 'k8-cred', namespace: 'webapps', restrictKubeConfigAccess: false, serverUrl: 'https://172.31.8.146:6443') {
                        sh "kubectl apply -f deployment-service.yaml"
                }
            }
        }
        
        stage('L09 - Verify the Deployment using Jenkins Pipeline Plugin') { // NOT-TESTED
            steps {
               withKubeConfig(caCertificate: '', clusterName: 'kubernetes', contextName: '', credentialsId: 'k8-cred', namespace: 'webapps', restrictKubeConfigAccess: false, serverUrl: 'https://172.31.8.146:6443') {
                        sh "kubectl get pods -n webapps"
                        sh "kubectl get svc -n webapps"
                }
            }
        }

        stage('L10 - Update K8S manifest & push to GitOps Repo') { // NOT-TESTED
        // this repo is from where mapped ArgoCD will pick up changes and apply onto the k8s cluster
            steps {
                script{
                    withCredentials([usernamePassword(credentialsId: 'f87a34a8-0e09-45e7-b9cf-6dc68feac670', passwordVariable: 'GIT_PASSWORD', usernameVariable: 'GIT_USERNAME')]) {
                        sh '''
                        cat deploy.yaml
                        sed -i '' "s/32/${BUILD_NUMBER}/g" deploy.yaml
                        cat deploy.yaml
                        git add deploy.yaml
                        git commit -m 'Updated the deploy yaml | Jenkins Pipeline'
                        git remote -v
                        git push https://github.com/iam-veeramalla/cicd-demo-manifests-repo.git HEAD:main
                        '''                        
                    }
                }
            }
        }


    stage('L11 - Update K8S manifest & push to GitOps Repo - Example 2') { // NOT-TESTED
      // The script block allows you to execute Groovy code within the pipeline
      script {
        // This function is used to catch any errors that occur within the block.
        // If an error occurs, the build's result is set to 'SUCCESS', but the stage's result is set to 'FAILURE'.
        // This means the build will continue even if the stage fails, but the stage itself will be marked as failed.
        catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
          // This block fetches the credentials stored in Jenkins (with the ID github) and makes them available in the script using the variables GIT_PASSWORD and GIT_USERNAME.
          // The credentials likely contain a GitHub username and a Personal Access Token (PAT) or password.
          withCredentials([usernamePassword(credentialsId: 'github', passwordVariable: 'GIT_PASSWORD', usernameVariable: 'GIT_USERNAME')]) {
            //def encodedPassword = URLEncoder.encode("$GIT_PASSWORD",'UTF-8')
            sh "git config user.email raj@cloudwithraj.com"
            sh "git config user.name RajSaha"
            //sh "git switch master"
            sh "cat deployment.yaml"
            // looks for any line containing raj80dockerid/test.* and replaces it with raj80dockerid/test:${DOCKERTAG}, where ${DOCKERTAG} is a variable likely representing the Docker image tag to be used in the Kubernetes manifest file.
            sh "sed -i 's+raj80dockerid/test.*+raj80dockerid/test:${DOCKERTAG}+g' deployment.yaml"
            // Prints the contents of the deployment.yaml file after modification.
            sh "cat deployment.yaml"
            sh "git add ."
            sh "git commit -m 'Done by Jenkins Job changemanifest: ${env.BUILD_NUMBER}'"
            sh "git push https://${GIT_USERNAME}:${GIT_PASSWORD}@github.com/${GIT_USERNAME}/gitops-project1-manifests.git HEAD:main"
          }
        }
      }
    }
    // **NOTE** i think this will make changes to deployment.yaml in CODE repo and then push it to GITOPS repo. maybe i should directly change on the GITOPS repo ?




  stage('L12 - Clone GitOps Repo and push manifest file changes to this GitOps Repo') {  // TESTED-AND-WORKS
    steps {
      PrintStageName()
      script {
        try {
        // Clone the GitOps repository
          echo 'Cloning the GitOps repository...'
          dir(env.APP_GITOPS_REPO_NAME) {
            withCredentials([usernamePassword(credentialsId: env.APP_GITOPS_CREDENTIALS_ID, usernameVariable: 'VAR_USER', passwordVariable: 'VAR_PAT')]) {
            // Use Jenkins git step to clone the repository securely
            // use the Git URL without credentials. they are still passed securely using the credentialsId parameter. 
            // Jenkins will handle authentication securely using its internal mechanisms (GIT_ASKPASS). 
            // This avoids insecure Groovy string interpolation while still providing the necessary credentials.
              echo "User extracted from Jenkins credentials ${env.APP_GITOPS_CREDENTIALS_ID} : ${env.VAR_USER}"
              echo "PAT (personal access token) extracted from Jenkins credentials ${env.APP_GITOPS_CREDENTIALS_ID} : ${env.VAR_PAT}"
              //git(branch: 'main', credentialsId: env.APP_GITOPS_CREDENTIALS, url: "https://${VAR_USER}:${VAR_PAT}@github.com/fedora800/stocksanalyzer-system.git")
              git(branch: env.APP_GITOPS_BRANCH, credentialsId: env.APP_GITOPS_CREDENTIALS_ID, url: "https://github.com/fedora800/${env.APP_GITOPS_REPO_NAME}.git")
 
              print 'username=' + VAR_USER 
              print 'password=' + VAR_PAT
              print 'username.collect { it } = ' + VAR_USER.collect { it }      // will print username.collect { it } = [f, e, d, o, r, a, 8, 0, 0]
              print 'password.collect { it } = ' + VAR_PAT.collect { it }

              def truncatedPAT = env.VAR_PAT.take(4)  // Take first 4 characters

              // Update requisite YAML files 
              echo '-------------------Updating YAML files... ---------------------------'
              sh """
              echo "User extracted from Jenkins credentials ${env.APP_GITOPS_CREDENTIALS_ID} : ${env.VAR_USER}"
              echo "PAT (personal access token) extracted from Jenkins credentials ${env.APP_GITOPS_CREDENTIALS_ID} : ${env.VAR_PAT}"
              echo "truncatedPAT : ${env.truncatedPAT}"
              pwd
              ls -lR
              echo "Now updating ${env.FILE_TO_CHANGE}"
              #cd kubernetes-manifests/frontend
              echo "Before image change :"
              grep "image: " ${env.FILE_TO_CHANGE}
              sed -i "s#image: .*stocksanalyzer-frontend-app.*#image: fedora800/stocksanalyzer-frontend-app:${env.APP_VERSION}#g" ${env.FILE_TO_CHANGE}
              echo "After image change :"
              grep "image: " ${env.FILE_TO_CHANGE}
              """
    
              // Commit and push the changes back to the GitOps repo
              echo 'Committing and pushing changes to GitOps repository...'
              sh """
              git config user.name "Jenkins"
              git config user.email "jenkins@example.com"
              git add ${env.FILE_TO_CHANGE}
              git commit -m "Jenkins CI - ${env.JOB_NAME} - Update deployment image for ${env.APP_NAME} to version ${env.APP_VERSION}"
              git remote -v
              git push https://${env.VAR_USER}:${env.VAR_PAT}@github.com/${env.GIT_USER_NAME}/${env.APP_GITOPS_REPO_NAME}.git ${env.APP_GITOPS_BRANCH}
              git log --pretty=format:'%h %ad %s    %D' --date=local -5
              """
              // This git push will evoke the webhook trigger on github on this gitops repo which the jenkins gitops pipeline is configured for, thus it gets fired
              
            } //with

          } //dir
        }  catch (Exception e) {
          echo "An error occurred: ${e.message}"
          // Fail the stage and stop the pipeline
          error("Stopping pipeline due to error in this stage.")
        } // try
      } // script
    } //steps
  } //stage



    stage('L13 - Connect to Kubernetes cluster using config file credentials and lookup resources') { //TESTED-AND-WORKS
      steps {
        PrintStageName()
        script {
          // Wrap with the credentials block to use the kubeconfig from Jenkins credentials into Jenkins env variable
          withCredentials([file(credentialsId: 'cred-kubernetes-config-file', variable: 'KUBECONFIG')]) {
            // Optionally check the cluster details
            sh 'kubectl config view'
            // Run your kubectl commands, for example, deploying an application
            sh 'kubectl get nodes -o wide'
            // Example of deploying a YAML manifest
            //sh 'kubectl apply -f deployment.yaml'
            // You can also run other kubectl commands as needed
            sh 'kubectl get pods -n ${K8S_NAMESPACE} -o wide'
          }
        }
      }
    }


    stage('L14 - Deploy to Kubernetes - Connect using config file credentials and APPLY manifest changes') {  //TESTED-AND-WORKS
      steps {
        PrintStageName()
        script {
          // Wrap with the credentials block to use the kubeconfig from Jenkins credentials into Jenkins env variable
          withCredentials([file(credentialsId: 'cred-kubernetes-config-file', variable: 'KUBECONFIG')]) {
            sh 'kubectl apply -f $K8S_DEPLOYMENT_FILE'
            sh 'kubectl apply -f $K8S_SERVICES_FILE'
            sh 'echo Waiting for 10 seconds for resource to come up...; sleep 10'
            sh 'kubectl -n ${K8S_NAMESPACE} get all --show-labels'

          }
        }
      }
    }


    stage('Update Deployment file') {
      environment {
        GIT_REPO_NAME = "End-to-End-Kubernetes-Three-Tier-DevSecOps-Project"
        GIT_USER_NAME = "AmanPathak-DevOps"
      }
      steps {
        dir('Kubernetes-Manifests-file/Frontend') {
          withCredentials([string(credentialsId: 'github', variable: 'GITHUB_TOKEN')]) {
            sh '''
              git config user.email "aman07pathak@gmail.com"
              git config user.name "AmanPathak-DevOps"
              BUILD_NUMBER=${BUILD_NUMBER}
            echo $BUILD_NUMBER
              imageTag=$(grep -oP '(?<=frontend:)[^ ]+' deployment.yaml)
              echo $imageTag
              sed -i "s/${AWS_ECR_REPO_NAME}:${imageTag}/${AWS_ECR_REPO_NAME}:${BUILD_NUMBER}/" deployment.yaml
              git add deployment.yaml
              git commit -m "Update deployment Image to version \${BUILD_NUMBER}"
              git push https://${GITHUB_TOKEN}@github.com/${GIT_USER_NAME}/${GIT_REPO_NAME} HEAD:master
              '''
          }
        }
      }
    }

        stage('Deploy to Kubernetes') {
            steps {
                withCredentials([string(credentialsId: 'k8s-credentials', variable: 'KUBE_TOKEN')]) {
                    sh 'kubectl --token=$KUBE_TOKEN apply -f deployment.yaml'
                }
                // Alternatively, use kubeconfig
                withCredentials([file(credentialsId: 'k8s-kubeconfig', variable: 'KUBECONFIG')]) {
                    sh 'kubectl apply -f deployment.yaml'
                }
            }
        }

-- 

        stage('Push Docker Image') {
            steps {
               script {
                   withDockerRegistry(credentialsId: 'docker-cred', toolName: 'docker') {
                            sh "docker push adijaiswal/boardshack:latest"
                    }
               }
            }
        }

        stage('Deploy To Kubernetes') {
            steps {
               withKubeConfig(caCertificate: '', clusterName: 'kubernetes', contextName: '', credentialsId: 'k8-cred', namespace: 'webapps', restrictKubeConfigAccess: false, serverUrl: 'https://172.31.8.146:6443') {
                        sh "kubectl apply -f deployment-service.yaml"
                }
            }
        }
        



    } // end-stages

    // -------------------- Do Post for all stages --------------------
    // post block example #1 for reference
    post {
        always {
            sh "docker-compose down || true"
        }

        success {
            bitbucketStatusNotify buildState: "SUCCESSFUL"
        }

        failure {
          // notify users when the Pipeline fails
          mail to: 'team@example.com',
          subject: "Failed Pipeline: ${currentBuild.fullDisplayName}",
          body: "Something is wrong with ${env.BUILD_URL}"
    }
    }


    //another post block example #2 for reference
    post {
        failure {
            emailext body: '''${SCRIPT, template="groovy-html.template"}''', 
                    subject: "${env.JOB_NAME} - Build # ${env.BUILD_NUMBER} - Failed", 
                    mimeType: 'text/html',to: "dmistry@yourhostdirect.com"
            }
         success {
               emailext body: '''${SCRIPT, template="groovy-html.template"}''', 
                    subject: "${env.JOB_NAME} - Build # ${env.BUILD_NUMBER} - Successful", 
                    mimeType: 'text/html',to: "dmistry@yourhostdirect.com"
          }      
    }


    //another post block example #3 for reference
    post {
      always {
          script {
              def jobName = env.JOB_NAME
              def buildNumber = env.BUILD_NUMBER
              def pipelineStatus = currentBuild.result ?: 'UNKNOWN'
              def bannerColor = pipelineStatus.toUpperCase() == 'SUCCESS' ? 'green' : 'red'
  
              def body = """
                  <html>
                  <body>
                  <div style="border: 4px solid ${bannerColor}; padding: 10px;">
                  <h2>${jobName} - Build ${buildNumber}</h2>
                  <div style="background-color: ${bannerColor}; padding: 10px;">
                  <h3 style="color: white;">Pipeline Status: ${pipelineStatus.toUpperCase()}</h3>
                  </div>
                  <p>Check the <a href="${BUILD_URL}">console output</a>.</p>
                  </div>
                  </body>
                  </html>
              """
  
              emailext (
                  subject: "${jobName} - Build ${buildNumber} - ${pipelineStatus.toUpperCase()}",
                  body: body,
                  to: 'jaiswaladi246@gmail.com',
                  from: 'jenkins@example.com',
                  replyTo: 'jenkins@example.com',
                  mimeType: 'text/html',
                  attachmentsPattern: 'trivy-image-report.html'
              )
          }
      }
  } // end-post

} // end-pipeline


//A00 -------------------- section : Functions --------------------
// functions need to be at the end of the code, outside of the pipeline section

// function to print the stage name more clearly in the jenkins console output, can be called within each stage
def PrintStageName() {  // TESTED-AND-WORKS
  echo "-----------------STAGE: ${env.STAGE_NAME}-----------------"
}


def captureRawPayload_method_1() { // TESTED-AND-WORKS

  // When a webhook is received by Jenkins, the Generic Webhook Trigger Plugin intercepts it.
  // The plugin extracts the raw body of the POST request.
  // It then sets this body as the value of the GENERIC_WEBHOOK_TRIGGER_REQUEST_BODY environment variable.
  // This environment variable is then available for use in the Jenkins pipeline script.

  // Capture the raw payload
  def rawPayload = env.GENERIC_WEBHOOK_TRIGGER_REQUEST_BODY ?: '{}'      // **** THIS DOES NOT CAPTURE IT, so not working, sets to {}  ****, but env has it, check there
  // Save the payload to a file in the workspace
  writeFile file: 'webhook_payload-X.json', text: rawPayload
  // Print the file path and contents
  echo "Raw payload saved to: ${env.WORKSPACE}/webhook_payload-X.json"
  sh '''
  ls -l webhook_payload-X.json
  cat webhook_payload-X.json
  '''

}

def captureRawPayload_method_2() { // TESTED-AND-WORKS

  // Print the entire payload data that was picked by the Generic Webhook Trigger Plugin 
  // A variable webhook_payload is configured on Jenkins under "Post content parameters"  with Expression = $ and JSONPATH option.
  // echo "webhook_payload = ${env.webhook_payload}"    // WORKS, but prints the huge json, so commented out for now

/*
Post content parameters
Name of variable = webhook_payload
Expression = $
JSONPATH
above expression means we want all the fields from the the payload put into this webhook_payload environment variable.

If we want the Header from the github webhook invocation, eg below - 
X-GitHub-Hook-Installation-Target-Type: repository
Go to "Header parameters" and add Request header = X-GitHub-Hook-Installation-Target-Type and leave Value filter blank
*/

  // Write the JSON content from the env variable to a file
  writeFile file: 'webhook_payload.json', text: "${env.webhook_payload}"

  // Optional: Print the content to verify
  sh '''
  pwd
  ls -l webhook_payload.json
  cat webhook_payload.json | cut -c1-1000
  '''
}


def extractWebhookInfo() { // TESTED-AND-WORKS

    // Parse the JSON formatted file into a json type of variable
    def jsonPayload = readJSON text: "${env.webhook_payload}"           // from the env variable
    //def jsonPayload = readJSON file: 'webhook_payload.json'             // from the saved file

    // html_url and git_url fields are typically part of the repository object, not at the root level of the payload
    def htmlUrl       = jsonPayload.repository?.html_url ?: 'Unknown'
    def gitUrl        = jsonPayload.repository?.git_url ?: 'Unknown'
    def repoName      = jsonPayload.repository.full_name ?: 'Unknown'
    def ref           = jsonPayload.ref ?: 'Unknown'
    def branchName    = jsonPayload.ref ? jsonPayload.ref.split('/')[-1] : 'Unknown'
    def commitId      = jsonPayload.after ?: 'Unknown'
    def commitMessage = jsonPayload.head_commit?.message ?: 'Unknown'
    def pusherName    = jsonPayload.pusher?.name ?: 'Unknown'
    echo "Printing main fields received on the GitHub webhook payload for build #${env.BUILD_NUMBER}"
    echo "HTML url: ${htmlUrl}"
    echo "git url: ${gitUrl}"
    echo "Repository: ${repoName}"
    echo "Ref: ${ref}"
    echo "Branch: ${branchName}"
    echo "Commit ID: ${commitId}"
    echo "Commit Message: ${commitMessage}"
    echo "Pushed by: ${pusherName}"
    // Store some values for use in the next section
    env.REPO_NAME = repoName
    env.COMMIT_ID = commitId
    
    // Construct a link between the webhook and the Jenkins build
    def buildLink = "${repoName} commit ${commitId} ${GITHUB_HOOK_TARGETID} fired Jenkins Build #${env.BUILD_NUMBER}"
    echo "Link: ${buildLink}"


}


def createBuildIdentifier() {  // TESTED-AND-WORKS
    def githubDeliveryId = env.HTTP_X_GITHUB_DELIVERY ?: 'Unknown'
    echo "GitHub Delivery ID: ${githubDeliveryId}"
    // Create a unique identifier linking GitHub webhook to Jenkins build
    def linkIdentifier = "${env.BUILD_NUMBER}-${githubDeliveryId}"
    echo "Unique Build Identifier: ${linkIdentifier}"
    // Set this as a build parameter for future reference
    env.GITHUB_JENKINS_LINK = linkIdentifier
    // Additional logging with stored values from previous section
    echo "This build (#${env.BUILD_NUMBER}) is for repository ${env.REPO_NAME}, commit ${env.COMMIT_ID}"
    // Log the Generic Webhook Trigger UUID
    echo "Generic Webhook Trigger UUID: ${params['jenkins-generic-webhook-trigger-plugin_uuid']}"
}



--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

to document properly


--

1. Use error to Fail the Stage
You can explicitly call the error function within your script block to fail the stage and stop the pipeline:

pipeline {
    agent any
    stages {
        stage('Example Stage') {
            steps {
                script {
                    try {
                        // Your commands that might fail
                        sh 'your-command'
                    } catch (Exception e) {
                        // Log the error message
                        echo "An error occurred: ${e.message}"
                        // Fail the stage and stop the pipeline
                        error("Stopping pipeline due to error in this stage.")
                    }
                }
            }
        }
        stage('Next Stage') {
            steps {
                echo "This stage will not run if the previous stage fails."
            }
        }
    }
}

The error function will cause the stage to fail, and the pipeline execution will stop. The subsequent stages will not run.

--

2. Use failFast to Fail Fast in a Parallel Execution

pipeline {
    agent any
    stages {
        stage('Parallel Stages') {
            failFast true // Fail fast if any parallel branch fails
            parallel {
                stage('Stage A') {
                    steps {
                        sh 'some-command'
                    }
                }
                stage('Stage B') {
                    steps {
                        sh 'another-command'
                    }
                }
            }
        }
        stage('Final Stage') {
            steps {
                echo "This will not run if any of the parallel stages fail."
            }
        }
    }
}

If you have multiple stages running in parallel and want to stop all of them when one fails, you can use the failFast option:
failFast true ensures that if any parallel stage fails, all other parallel executions are stopped, and the pipeline will not proceed to the next stage.

--

3. Use when Condition to Skip Stages Based on Previous Stage Status
pipeline {
    agent any
    stages {
        stage('First Stage') {
            steps {
                script {
                    // Your build step
                    def result = sh(script: 'some-command', returnStatus: true)
                    if (result != 0) {
                        error("First Stage failed. Exiting pipeline.")
                    }
                }
            }
        }
        stage('Second Stage') {
            when {
                expression {
                    currentBuild.result == null || currentBuild.result == 'SUCCESS'
                }
            }
            steps {
                echo "This stage will run only if the previous stage was successful."
            }
        }
    }
}

The when directive with an expression condition checks if the previous stage was successful before running the current stage. If the previous stage failed, the current stage will be skipped.

--

4. Use post Block to Handle Failures

The post block allows you to define actions to take when a stage or the entire pipeline fails:

pipeline {
    agent any
    stages {
        stage('Example Stage') {
            steps {
                sh 'some-failing-command'
            }
            post {
                failure {
                    echo "Stage failed. Stopping pipeline."
                    error("Exiting pipeline due to stage failure.")
                }
            }
        }
        stage('Next Stage') {
            steps {
                echo "This stage will not run if the previous stage fails."
            }
        }
    }
}

The post block with failure allows you to define actions to take if the stage fails, such as sending notifications or logging errors. Using error within post ensures the pipeline stops.

--





